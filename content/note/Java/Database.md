---
title: 数据库原理
subtitle: 
layout: post
date: 2021-09-04
author: heavenmei
categories:
  - Note
description: 
tags:
  - Java
image:
---


## 数据库的安全与保护

**DBMS所提供的数据库安全和保护功能**

1. 安全性保护
2. 完整性保护
3. 并发控制
4. 数据库恢复



### 安全性保护

防止用户非法的使用数据库，包括恶意破坏和越权存取数据，即防范对象是非法用户和非法操作

1. 用户鉴别
2. 存取权限控制
3. 视图机制
4. 跟踪审查
5. 数据加密存储



### 完整性保护

防止合法用户使用数据库是数据库中加入不合语义规定的数据，即防范对象是不合语义规定的数据

**作用对象：**列、元组、关系

**完整性约束分类：**

1. 静态约束、动态约束
2. 立即执行的约束；、延迟执行的约束
3. 实体完整性约束、参照完整性约束、用户定义的完整性约束

**触发器：**

建立（附着）在某个关系（基本表）上的一系列SQL语句的集合（程序），且经预先编译后存储在数据库中。实现数据库的完整性约束和安全保护



### 并发技术

#### 事务(transaction)

**要么都成功，要么都失败**

- 事务就是将一组SQL语句放在<u>同一批次</u>内去执行
- 如果一个SQL语句出错,则该批次内的所有SQL都将被取消执行
- MySQL事务处理只支持InnoDB和BDB数据表类型

***

1. SQL执行 A给B转账     A 1000  -->200  B 200
2. SQL执行 B收到A的钱  A 800   --> B 400

***

> [事务的ACID原则](https://blog.csdn.net/dengjili/article/details/82468576)  (脏读、幻读)

**原子性(Atomic)**

- 原子性是指事务是一个不可分割的工作单位，事务中的操作<u>要么都发生，要么都不发生</u>。

**一致性(Consist)**

- 事务前后数据的完整性必须保持一致。

**隔离性(Isolated)**

- 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。

**持久性(Durable)**

- 持久性是指一个事务<u>一旦被提交不可逆</u>，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响



#### 并发控制（多事务执行）

串行访问、并发访问、交叉并发、同时并发

###### 并发所导致的一些问题

> **丢失修改**：两个事务T1、T2同时读入同一数据并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改被丢失
>
> **脏读：**指一个事务读取了另外一个事务未提交的数据。
>
> **不可重复读：**在一个事务内读取表中的某一行数据，多次读取结果不同。（这个不一定是错误，只是某些场合不对）
>
> **虚读(幻读)**是指在一个事务内读取到了别的事务插入的数据，导致前后读取数量总量不一致。（一般是行影响）



###### 并发控制方法-封锁

封锁是事务T在对某个数据对象（例如表、记录等操作时）。先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他事务不能更新此数据对象。



封锁的类型：

> **排他锁**：简称X锁（又称写锁），若事务T对数据对象A加上X锁，则***只允许T读取和修改A***，其他任何事务都不能再对A加任何锁。直到T释放A上的锁。
> **共享锁**：简称S锁（又称读锁），若事务T对数据对象A加上S锁，则***事务T可以读A但不能修改A***，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁为止。



封锁粒度：被封锁数据对象的大小。

1. 物理单元：页（数据页或索引页）、物理记录等
2. 逻辑单元：属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库



封锁协议：

>**封锁协议**：约定了对数据对象何时申请X锁或S锁，持续时间、何时释放等一系列规则.
>
>**1.一级封锁协议**：事务T在***修改数据R之前***必须先对其加***X锁***，直到***事务结束才释放***。（事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK））。
>
>**2. 二级封锁协议**：在一级封锁协议的基础上增加事务T在***读取数据R之前***必须先对其加***S锁***，***读完后***即可释放S锁
>
>**3. 三级封锁协议**：在一级封锁协议的基础上增加事务T在***读取数据R之前***必须先对其加***S锁***，直到***事务结束才释放。***



###### 封锁会带来哪些问题呢？

**活锁：**如果事务T1封锁了数据R，事务T2又请求封锁数据R，于是T2等待；T3也请求封锁数据R，当T1释放了R上的锁之后，系统首先批准了T3的请求，T2任然等待；然后T4又请求封锁R，当T3释放R上的锁之后，系统又批准了T4的请求……***T2有可能永远等待***，这就是活锁的情况。

​	避免活锁的简单方法是：采用***先来先服务策略***



**死锁：**如果事务T1封锁了数据R1，T2封锁了数据R2，然后T1又请求封锁R2，因T2封锁了R2,于是T1等待T2释放R2上的锁；接着T2又请求封锁R1，因T1封锁了R1，于是T2等待T1释放R1上的锁。这样就***出现了T1在等待T2,而T2又在等待T1的局面***，T1、T2两个事务永远不能结束，形成死锁

<font color="blue">解决死锁的方法：有两种思路</font>

1. 预防法

    - 一次封锁法：一次性将所有要使用的数据全部加锁，否则就不能继续执行
- 顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按照这个顺序实施封锁
  
2. 诊断接触法

   应用程序诊断程序发现死锁产生后，通过解锁程序排除死锁







## 数据库设计与实施

### 数据库设计步骤

1. `规划时期`：明确数据库建设的总体目标和技术路线，得出数据库设计项目的可行性分析报告，对数据库设计的进度和人员分工做出安排。

2. `设计时期`

   1. `需求分析阶段`：
   2. `概念结构设计阶段`：E-R图
   3. `逻辑结构设计阶段`：使概念结构转换为某个DBMS所支持的数据模型，并进行优化。
   4. `物理结构设计阶段`：设为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）。

3. `实施时期`

4. `运行与维护时期`




### 数据字典

描述每个数据流，每个文件，每个加工的集合，是对数据流图中出现的所有数据元素给出逻辑定义和描述。

数据字典包括**数据项**，**数据文件**，**数据流**，**数据存储**，**处理过程**。

- 数据项描述= (数据项名，别名，数据项含义，数据类型，字节长度，取值范围，取值含义，与其他数据项的逻辑关系)
- 数据文件描述=(数据文件名，所有数据项名，数据存取频度，存取方式)
- 数据流描述=(数据流名称，所有数据项名，数据流来源，数据流去向，平均流量，峰值流量)
- 数据加工处理描述=(加工处理名，说明，输入的数据流名，输出的数据流名，处理要求)


### 概念结构设计

是将用户需求抽象为信息结构（概念模型）的过程。

1. **局部E-R图的设计**：确定局部范围、定义实体型、定义联系
2. **全局E-R图的设计**：确定公共实体型、合并局部E-R模式、消除冲突
3. **全局E-R图的优化**



### 逻辑结构设计

把概念设计阶段的全局`E-R`图转换成`DBMS`支持的数据模型。

1. 实体型的转换

2. 联系的转换

3. 关系模式的优化

   

### 物理结构设计

目前流行的额商品化关系数据库管理系统（RDBMS）中，数据库的大量内部物理结构有RDBMS自动完成，留给用户参与设计的物理结构内容有：

1. 聚簇设计
2. 索引设计
3. 分区设计
4. 确定系统配置参数
5. 评价物理结构设计



