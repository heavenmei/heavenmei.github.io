---
title: Java 之 基础篇 (一)
subtitle: 
layout: post
date: 2021-08-01
author: heavenmei
categories:
  - Note
description: 
tags:
  - Java
image:
---

## Menu
- [一、基础篇](#一基础篇)
  - [网络基础](#网络基础)
    - [**TCP 三次握手**](#tcp三次握手)
      - [**1、OSI 与 TCP/IP 模型**](#1osi与tcpip-模型)
      - [**2、常见网络服务分层**](#2常见网络服务分层)
      - [**3、TCP 与 UDP 区别及场景**](#3tcp与udp区别及场景)
      - [**4、TCP 滑动窗口，拥塞控制**](#4tcp滑动窗口拥塞控制)
      - [**5、TCP 粘包原因和解决方法**](#5tcp粘包原因和解决方法)
      - [**6、TCP、UDP 报文格式**](#6tcpudp报文格式)
    - [**HTTP 协议**](#http协议)
      - [1、HTTP 协议 1.0_1.1_2.0](#1http协议10_11_20)
      - [2、HTTP 与 HTTPS 之间的区别](#2http与https之间的区别)
      - [**3、Get 和 Post 请求区别**](#3get和post请求区别)
      - [**4、HTTP 常见响应状态码**](#4http常见响应状态码)
      - [**5、重定向和转发区别**](#5重定向和转发区别)
      - [**6、Cookie 和 Session 区别。**](#6cookie和session区别)
    - [**浏览器输入 URL 过程**](#浏览器输入url过程)
  - [**操作系统基础**](#操作系统基础)
    - [**进程和线程的区别**](#进程和线程的区别)
      - [**1、进程间通信方式 IPC**](#1进程间通信方式ipc)
      - [**2、用户态和核心态**](#2用户态和核心态)
      - [**3、操作系统的进程空间**](#3操作系统的进程空间)
    - [操作系统内存管理](#操作系统内存管理)
      - [**1、页面置换算法 FIFO、LRU**](#1页面置换算法fifolru)
      - [**2、死锁条件、解决方式。**](#2死锁条件解决方式)
  - [**Java 基础**](#java基础)
    - [面向对象三大特性](#面向对象三大特性)
      - [**1、Java 与 C++区别**](#1java与c区别)
      - [**2、多态实现原理**](#2多态实现原理)
      - [3、static 和 final 关键字](#3static和final关键字)
      - [4、抽象类和接口](#4抽象类和接口)
      - [5、泛型以及泛型擦除](#5泛型以及泛型擦除)
      - [**6、反射原理以及使用场景**](#6反射原理以及使用场景)
      - [**7、Java 异常体系**](#7java异常体系)
    - [数据结构](#数据结构)
      - [**1、ArrayList 和 LinkedList**](#1arraylist和linkedlist)
      - [**2、List 遍历快速和安全失败**](#2list遍历快速和安全失败)
      - [**3、详细介绍 HashMap**](#3详细介绍hashmap)
      - [**4、ConcurrentHashMap **](#4concurrenthashmap-)
      - [**5、序列化和反序列化**](#5序列化和反序列化)
      - [**6、String**](#6string)
    - [设计模式与原则](#设计模式与原则)
      - [1、单例模式](#1单例模式)
      - [2、工厂模式](#2工厂模式)
      - [3、抽象工厂模式](#3抽象工厂模式)
  - [面试题](#面试题)
    - [构造方法](#构造方法)
    - [初始化块](#初始化块)
    - [This](#this)
    - [**重写和重载的区别**](#重写和重载的区别)
    - [Object 类方法](#object类方法)
    - [基本数据类型和包装类](#基本数据类型和包装类)
- [二、JVM 篇](#二jvm篇)
  - [**JVM 内存划分**](#jvm内存划分)
    - [**1、JVM 运行时数据区域**](#1jvm运行时数据区域)
    - [**2、堆内存分配策略**](#2堆内存分配策略)
    - [**3、创建一个对象的步骤**](#3创建一个对象的步骤)
    - [4、**对象引用**](#4对象引用)
  - [**JVM 类加载过程**](#jvm类加载过程)
    - [**1、双亲委派机制**](#1双亲委派机制)
    - [**2、tomcat 的类加载机制**](#2tomcat的类加载机制)
  - [JVM 垃圾回收](#jvm垃圾回收)
    - [**1、存活算法和两次标记过程**](#1存活算法和两次标记过程)
    - [**2、垃圾回收算法**](#2垃圾回收算法)
      - [**MinorGC、MajorGC、FullGC**](#minorgcmajorgcfullgc)
    - [**3、垃圾收集器**](#3垃圾收集器)
    - [**4、配置垃圾收集器**](#4配置垃圾收集器)
    - [**4、JVM 性能调优**](#4jvm性能调优)
    - [5、JDK 新特性](#5jdk新特性)
  - [线上故障排查](#线上故障排查)
    - [1、硬件故障排查](#1硬件故障排查)
    - [2、报表异常 | JVM 调优](#2报表异常--jvm调优)
    - [3、大屏异常 | JUC 调优](#3大屏异常--juc调优)
    - [**4、接口延迟 | SWAP 调优**](#4接口延迟--swap调优)
    - [5、**内存溢出 | Cache 调优**](#5内存溢出--cache调优)
    - [6：CPU 飙高 | 死循环](#6cpu飙高--死循环)
- [三、多线程篇](#三多线程篇)
  - [线程调度](#线程调度)
    - [**1、线程状态**](#1线程状态)
    - [**2、线程状态切换**](#2线程状态切换)
    - [**3、阻塞唤醒过程**](#3阻塞唤醒过程)
    - [**4、wait 和 sleep 区别**](#4wait和sleep区别)
    - [5、创建线程方式](#5创建线程方式)
  - [线程池](#线程池)
    - [**1、线程池构造函数**](#1线程池构造函数)
    - [**2、线程处理任务过程：**](#2线程处理任务过程)
    - [**3、线程拒绝策略**](#3线程拒绝策略)
    - [**4、Execuors 类实现线程池**](#4execuors类实现线程池)
    - [**5、线程池大小设置**](#5线程池大小设置)
  - [线程安全](#线程安全)
    - [**1、乐观锁，CAS 思想**](#1乐观锁cas思想)
    - [**2、synchronized 底层实现**](#2synchronized底层实现)
    - [**3、ReenTrantLock 底层实现**](#3reentrantlock底层实现)
    - [**4、公平锁和非公平锁区别**](#4公平锁和非公平锁区别)
    - [**5、使用层面锁优化**](#5使用层面锁优化)
    - [6、系统层面锁优化](#6系统层面锁优化)
    - [**7、ThreadLocal 原理**](#7threadlocal原理)
    - [**8、HashMap 线程安全**](#8hashmap线程安全)
    - [9、String 不可变原因](#9string不可变原因)
  - [内存模型](#内存模型)
    - [**1、volatile 底层实现**](#1volatile底层实现)
    - [**2、AQS 思想**](#2aqs思想)
    - [3、happens-before](#3happens-before)
- [四、MySQL 篇](#四mysql篇)
  - [WhyMysql？](#whymysql)
    - [海量 Aerospike](#海量aerospike)
    - [图谱 Neo4j](#图谱neo4j)
    - [**文档 MongoDB**](#文档mongodb)
    - [**云存储**](#云存储)
    - [**FastDFS**](#fastdfs)
  - [事务](#事务)
    - [**1、事务 4 大特性**](#1事务4大特性)
    - [**2、事务隔离级别**](#2事务隔离级别)
    - [**3、默认隔离级别-RR**](#3默认隔离级别-rr)
    - [**4、RR 和 RC 使用场景**](#4rr和rc使用场景)
    - [**5、行锁，表锁，意向锁**](#5行锁表锁意向锁)
    - [**6、MVCC 多版本并发控制**](#6mvcc多版本并发控制)
  - [索引](#索引)
    - [**1、Innodb 和 Myisam 引擎**](#1innodb和myisam引擎)
    - [**2、哈希索引**](#2哈希索引)
    - [**3、B+树索引**](#3b树索引)
    - [4、创建索引](#4创建索引)
    - [**5、聚簇索引和非聚簇索引**](#5聚簇索引和非聚簇索引)
    - [6、最左前缀问题](#6最左前缀问题)
  - [SQL 查询](#sql查询)
    - [**1、SQL 语句的执行过程**](#1sql语句的执行过程)
    - [**2、回表查询和覆盖索引**](#2回表查询和覆盖索引)
    - [3、Explain 及优化](#3explain及优化)
    - [4、JOIN 查询](#4join查询)
  - [**集群**](#集群)
    - [1、主从复制过程](#1主从复制过程)
    - [2、数据一致性问题](#2数据一致性问题)
    - [3、集群架构](#3集群架构)
    - [4、故障转移和恢复](#4故障转移和恢复)
  - [面试题](#面试题-1)
    - [分库分表](#分库分表)
      - [如何进行分库分表](#如何进行分库分表)
    - [如何将老数据进行迁移](#如何将老数据进行迁移)
    - [系统性能的评估及扩容](#系统性能的评估及扩容)
    - [如何生成自增的 id 主键](#如何生成自增的id主键)
  - [线上故障及优化](#线上故障及优化)
    - [更新失败 | 主从同步延时](#更新失败--主从同步延时)
    - [**应用崩溃 | 分库分表优化**](#应用崩溃--分库分表优化)
    - [查询异常 | SQL 调优](#查询异常--sql-调优)
- [**五、Redis 篇**](#五redis篇)
  - [WhyRedis](#whyredis)
    - [1、简单高效](#1简单高效)
    - [2、Memcache](#2memcache)
    - [3、Tair](#3tair)
    - [4、Guava](#4guava)
    - [5、EVCache](#5evcache)
    - [6、ETCD](#6etcd)
  - [Redis 底层](#redis底层)
    - [1、redis 数据类型](#1redis数据类型)
    - [**2、相关 API**](#2相关api)
    - [3、redis 底层结构](#3redis底层结构)
    - [4、Zset 底层实现](#4zset底层实现)
  - [**Redis 可用性**](#redis可用性)
    - [1、redis 持久化](#1redis持久化)
    - [2、redis 事务](#2redis事务)
    - [3、redis 失效策略](#3redis失效策略)
    - [4、redis 读写模式](#4redis读写模式)
    - [5、多级缓存](#5多级缓存)
  - [Redis 七大经典问题](#redis七大经典问题)
    - [1、缓存雪崩](#1缓存雪崩)
    - [**2、缓存穿透**](#2缓存穿透)
    - [**3、缓存击穿**](#3缓存击穿)
    - [4、数据不一致](#4数据不一致)
    - [5、数据并发竞争](#5数据并发竞争)
    - [6、热点 key 问题](#6热点key问题)
    - [7、BigKey 问题](#7bigkey问题)
  - [Redis 分区容错](#redis分区容错)
    - [**1、redis 数据分区**](#1redis数据分区)
    - [**2、主从模式=简单**](#2主从模式简单)
    - [3、**哨兵模式**=读多](#3哨兵模式读多)
    - [4、集群模式=写多](#4集群模式写多)
    - [5、分布式锁](#5分布式锁)
    - [6、redis 心跳检测](#6redis心跳检测)
  - [Redis 实战](#redis实战)
    - [1、Redis 优化](#1redis优化)
    - [2、Redis 热升级](#2redis热升级)
- [六、Kafka 篇](#六kafka篇)
  - [Why kafka](#why-kafka)
  - [What Kafka](#what-kafka)
  - [How Kafka](#how-kafka)
  - [**生产消费基本流程**](#生产消费基本流程)
  - [一致性](#一致性)
  - [可用性](#可用性)
  - [面试题](#面试题-2)
    - [**线上问题 rebalance**](#线上问题rebalance)
    - [ZooKeeper 的作用](#zookeeper-的作用)
    - [Replica 副本的作用](#replica副本的作用)
    - [为什么不支持读写分离?](#为什么不支持读写分离)
    - [如何防止重复消费](#如何防止重复消费)
    - [**如何保证数据不会丢失**](#如何保证数据不会丢失)
    - [**如何保证顺序消费**](#如何保证顺序消费)
    - [【线上】如何解决积压消费](#线上如何解决积压消费)
    - [如何避免消息积压](#如何避免消息积压)
    - [如何设计消息队列](#如何设计消息队列)
- [七、Spring 篇](#七spring篇)
  - [设计思想&Beans](#设计思想beans)
    - [**1、IOC 控制反转**](#1ioc-控制反转)
    - [**2、AOP 动态代理**](#2aop-动态代理)
    - [**3、Bean 生命周期**](#3bean生命周期)
    - [**4**、Bean 作用域](#4bean作用域)
    - [5、循环依赖](#5循环依赖)
  - [Spring 注解](#spring注解)
    - [1、@SpringBoot](#1springboot)
    - [**2、@SpringMVC**](#2springmvc)
    - [3、@SpringMybatis](#3springmybatis)
    - [4、@Transactional](#4transactional)
  - [Spring 源码阅读](#spring源码阅读)
    - [**1、Spring 中的设计模式**](#1spring中的设计模式)
- [八、SpringCloud 篇](#八springcloud篇) - [Why SpringCloud](#why-springcloud) - [Spring Boot](#spring-boot) - [GateWay / Zuul](#gateway--zuul) - [Eureka / Zookeeper](#eureka--zookeeper) - [Feign / Ribbon](#feign--ribbon) - [Hystrix / Sentinel](#hystrix--sentinel) - [Config / Nacos](#config--nacos) - [Bus / Stream](#bus--stream) - [**Sleuth / Zipkin**](#sleuth--zipkin)
  - [**安全认证**](#安全认证)
  - [灰度发布](#灰度发布)
  - [多版本隔离](#多版本隔离)
    - [**各组件调优**](#各组件调优)
- [**九、分布式篇**](#九分布式篇)
  - [**发展历程**](#发展历程)
  - [CAP](#cap)
  - [一致性](#一致性-1)
    - [XA 方案](#xa方案)
    - [**Paxos 算法**](#paxos算法)
    - [**ZAB 算法**](#zab算法)
    - [Raft 算法](#raft算法)
    - [数据库和 Redis 的一致性](#数据库和redis的一致性)
  - [可用性](#可用性-1)
    - [**心跳检测**](#心跳检测)
    - [**多机房实时热备**](#多机房实时热备)
  - [分区容错性](#分区容错性)
    - [日志复制](#日志复制)
    - [**主备（Master-Slave）**](#主备master-slave)
    - [**互备（Active-Active）**](#互备active-active)
    - [**集群（Cluster）模式**](#集群cluster模式)
  - [分布式事务](#分布式事务)
    - [XA 方案](#xa方案-1)
    - [TCC 方案](#tcc方案)
    - [**Saga 方案**](#saga方案)
    - [**本地消息表（eBay）**](#本地消息表ebay)
    - [**MQ 最终一致性**](#mq最终一致性)
    - [最大努力通知方案（订单 -> 积分）](#最大努力通知方案订单---积分)
  - [面试题](#面试题-3)
    - [分布式 Session 实现方案](#分布式session实现方案)


## 网络基础

### **TCP 三次握手**

​ **三次握手过程：**

​ 客户端——发送带有 SYN 标志的数据包——服务端 **一次握手** Client 进入 syn_sent 状态

​ 服务端——发送带有 SYN/ACK 标志的数据包——客户端 **二次握手** 服务端进入 syn_rcvd

​ 客户端——发送带有 ACK 标志的数据包——服务端 **三次握手** 连接就进入 Established 状态

​ **为什么三次：**

​ 主要是为了建立可靠的通信信道，保证客户端与服务端同时具备发送、接收数据的能力

​ **为什么两次不行？**

​ 1、防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源

​ 2、 两次握手只能保证单向连接是畅通的。（为了实现可靠数据传输， TCP 协议的通信双方， 都必须维 护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方 相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认）

**TCP 四次挥手过程 **

**四次挥手过程：**

​ 客户端——发送带有 FIN 标志的数据包——服务端，关闭与服务端的连接 ，客户端进入 FIN-WAIT-1 状态

​ 服务端收到这个 FIN，它发回⼀ 个 ACK，确认序号为收到的序号加 1，服务端就进入了 CLOSE-WAIT 状态

​ 服务端——发送⼀个 FIN 数据包——客户端，关闭与客户端的连接，客户端就进入 FIN-WAIT-2 状态

​ 客户端收到这个 FIN，发回 ACK 报⽂确认，并将确认序号设置为收到序号加 1，TIME-WAIT 状态

**为什么四次：**

​ 因为需要确保客户端与服务端的数据能够完成传输。

**CLOSE-WAIT：**

​ 这种状态的含义其实是表示在等待关闭

**TIME-WAIT：**

​ 为了解决网络的丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接

**如何查看 TIME-WAIT 状态的链接数量？**

​ netstat -an |grep TIME_WAIT|wc -l 查看连接数等待 time_wait 状态连接数

**为什么会 TIME-WAIT 过多？解决方法是怎样的？**

​ **可能原因：** 高并发短连接的 TCP 服务器上，当服务器处理完请求后立刻按照主动正常关闭连接

​ **解决：**负载均衡服务器；Web 服务器首先关闭来自负载均衡服务器的连接

#### **1、OSI 与 TCP/IP 模型**

​ OSI 七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

​ TCP/IP 五层：物理层、数据链路层、网络层、传输层、应用层

#### **2、常见网络服务分层**

​ 应用层：HTTP、SMTP、DNS、FTP

​ 传输层：TCP 、UDP

​ 网络层：ICMP 、IP、路由器、防火墙

​ 数据链路层：网卡、网桥、交换机

​ 物理层：中继器、集线器

#### **3、TCP 与 UDP 区别及场景**

| 类型 |            特点            |          性能          |    应用过场景    | 首部字节 |     |
| ---- | :------------------------: | :--------------------: | :--------------: | :------: | --- |
| TCP  |   面向连接、可靠、字节流   | 传输效率慢、所需资源多 |  文件、邮件传输  |  20-60   |     |
| UDP  | 无连接、不可靠、数据报文段 | 传输效率快、所需资源少 | 语音、视频、直播 | 8 个字节 |     |

​ **基于 TCP 的协议：**HTTP、FTP、SMTP

​ **基于 UDP 的协议：**RIP、DNS、SNMP

#### **4、TCP 滑动窗口，拥塞控制**

​ **TCP 通过：**应用数据分割、对数据包进行编号、校验和、流量控制、拥塞控制、超时重传等措施保证数据的可靠传输；

​ **拥塞控制目的：**为了防止过多的数据注入到网络中，避免网络中的路由器、链路过载

​ **拥塞控制过程：**TCP 维护一个拥塞窗口，该窗口随着网络拥塞程度动态变化，通过慢开始、拥塞避免等算法减少网络拥塞的发生。

#### **5、TCP 粘包原因和解决方法**

​ **TCP 粘包是指**：发送方发送的若干包数据到接收方接收时粘成一包

​ **发送方原因：**

​ TCP 默认使用 Nagle 算法（主要作用：减少网络中报文段的数量）：

​ 收集多个小分组，在一个确认到来时一起发送、导致发送方可能会出现粘包问题

​ **接收方原因：**

​ TCP 将接收到的数据包保存在接收缓存里，如果 TCP 接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。

​ **解决粘包问题：**

​ 最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：

- 发送定长包。每个消息的大小都是一样的，接收方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。

- 包尾加上\r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。

- 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。

#### **6、TCP、UDP 报文格式**

​ **TCP 报文格式：**


![](https://farm1.staticflickr.com/792/27194088468_4cb0141fc8_b.jpg)
​ **源端口号和目的端口号**：

​ 用于寻找发端和收端应用进程。这两个值加上 ip 首部源端 ip 地址和目的端 ip 地址唯一确定一个 tcp 连接。

​ **序号字段：**

​ 序号用来标识从 T C P 发端向 T C P 收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则 T C P 用序号对每个字节进行计数。序号是 32 bit 的无符号数，序号到达 2^32-1 后又从 0 开始。

当建立一个新的连接时，SYN 标志变 1。序号字段包含由这个主机选择的该连接的初始序号 ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个 ISN 加 1，因为 SYN 标志消耗了一个序号

​ **确认序号**：

​ 既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加 1。只有 ACK 标志为 1 时确认序号字段才有效。发送 ACK 无需任何代价，因为 32 bit 的确认序号字段和 A C K 标志一样，总是 T C P 首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置， ACK 标志也总是被设置为 1。TCP 为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。

​ **首都长度**：

​ 首部长度给出首部中 32 bit 字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占 4 bit，因此 T C P 最多有 6 0 字节的首部。然而，没有任选字段，正常的长度是 2 0 字节。

​ **标志字段**：在 T C P 首部中有 6 个标志比特。它们中的多个可同时被设置为 1.
　　 URG 紧急指针（u rgent pointer）有效
　　 ACK 确认序号有效。
　　 PSH 接收方应该尽快将这个报文段交给应用层。
　　 RST 重建连接。
　　 SYN 同步序号用来发起一个连接。这个标志和下一个标志将在第 1 8 章介绍。
　　 FIN 发端完成发送任务。

​ **窗口大小**：

​ T C P 的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端期望接收的字节。窗口大小是一个 16 bit 字段，因而窗口大小最大为 65535 字节。

​ **检验和：**

​ 检验和覆盖了整个的 T C P 报文段：T C P 首部和 T C P 数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。

​ **紧急指针**：

​ 只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 T C P 的紧急方式是发送端向另一端发送紧急数据的一种方式。

​ **选项**：

​ 最常见的可选字段是最长报文大小，又称为 MSS (Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置 S Y N 标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。

​ **UDP 报文格式：**

![](https://appwk.baidu.com/naapi/doc/view?ih=482&o=png_6_0_0_176_917_504_247_892.979_1262.879&iw=986&ix=0&iy=0&aimw=986&rn=1&doc_id=182d935c3186bceb18e8bb77&pn=1&sign=b88bda03b9954e506622f97b8b2ae438&type=1&app_ver=2.9.8.2&ua=bd_800_800_IncredibleS_2.9.8.2_2.3.7&bid=1&app_ua=IncredibleS&uid=&cuid=&fr=3&Bdi_bear=WIFI&from=3_10000&bduss=&pid=1&screen=800_800&sys_ver=2.3.7)

​ **端口号**：

​ 用来表示发送和接受进程。由于 I P 层已经把 I P 数据报分配给 T C P 或 U D P（根据 I P 首部中协议字段值），因此 T C P 端口号由 T C P 来查看，而 U D P 端口号由 UDP 来查看。T C P 端口号与 UDP 端口号是相互独立的。

​ **长度**：

​ UDP 长度字段指的是 UDP 首部和 UDP 数据的字节长度。该字段的最小值为 8 字节（发送一份 0 字节的 UDP 数据报是 O K）。

​ **检验和**：

​ UDP 检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现 UDP 首部和数据在发送端到接收端之间发生的任何改动。

​ **IP 报文格式：**普通的 IP 首部长为 20 个字节，除非含有可选项字段。

​
​ **4 位版本**：

​ 目前协议版本号是 4，因此 IP 有时也称作 IPV4.

​ **4 位首部长度**：

​ 首部长度指的是首部占 32bit 字的数目，包括任何选项。由于它是一个 4 比特字段，因此首部长度最长为 60 个字节。

​ **服务类型（TOS）**：

​ 服务类型字段包括一个 3bit 的优先权字段（现在已经被忽略），4bit 的 TOS 子字段和 1bit 未用位必须置 0。4bit 的 TOS 分别代表：最小时延，最大吞吐量，最高可靠性和最小费用。4bit 中只能置其中 1 比特。如果所有 4bit 均为 0，那么就意味着是一般服务。

​ **总长度**：

​ 总长度字段是指整个 IP 数据报的长度，以字节为单位。利用首部长度和总长度字段，就可以知道 IP 数据报中数据内容的起始位置和长度。由于该字段长 16bit，所以 IP 数据报最长可达 65535 字节。当数据报被分片时，该字段的值也随着变化。

​ **标识字段**：

​ 标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加 1。

​ **生存时间**：

​ TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL 的初始值由源主机设置（通常为 3 2 或 6 4），一旦经过一个处理它的路由器，它的值就减去 1。当该字段的值为 0 时，数据报就被丢弃，并发送 ICMP 报文通知源主机。

​ **首部检验和**：

​ 首部检验和字段是根据 I P 首部计算的检验和码。它不对首部后面的数据进行计算。 ICMP、IGMP、UDP 和 TCP 在它们各自的首部中均含有同时覆盖首部和数据检验和码。

​ **以太网报文格式：**

![](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2733576797,55677727&fm=26&gp=0.jpg)

​ **目的地址和源地址：**

​ 是指网卡的硬件地址（也叫 MAC 地址），长度是 48 位，是在网卡出厂时固化的。

​ **数据：**

​ 以太网帧中的数据长度规定最小 46 字节，最大 1500 字节，ARP 和 RARP 数据包的长度不够 46 字节，要在后面补填充位。最大值 1500 称为以太网的最大传输单元（MTU），不同的网络类型有不同的 MTU，如果一个数据包从以太网路由到拨号链路上，数据包度大于拨号链路的 MTU 了，则需要对数据包进行分片 fragmentation）。ifconfig 命令的输出中也有“MTU:1500”。注意，MTU 个概念指数据帧中有效载荷的最大长度，不包括帧首部的长度。

### **HTTP 协议**

#### 1、HTTP 协议 1.0_1.1_2.0

​ **HTTP1.0：**服务器处理完成后立即断开 TCP 连接（**无连接**），服务器不跟踪每个客户端也不记录过去的请求（**无状态**）

​ **HTTP1.1：**KeepAlived**长连接**避免了连接建立和释放的开销；通过 Content-Length 来判断当前请求数据是否已经全部接受（**有状态**）

​ **HTTP2.0：**引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以**并行**的传输数据。

​ **http1.0 和 http1.1 的主要区别如下：**
​ 1、缓存处理：1.1 添加更多的缓存控制策略（如：Entity tag，If-Match）
​ 2、网络连接的优化：1.1 支持断点续传
​ 3、错误状态码的增多：1.1 新增了 24 个错误状态响应码，丰富的错误码更加明确各个状态
​ 4、Host 头处理：支持 Host 头域，不在以 IP 为请求方标志
​ 5、长连接：减少了建立和关闭连接的消耗和延迟。

​ **http1.1 和 http2.0 的主要区别：**
​ 1、新的传输格式：2.0 使用二进制格式，1.0 依然使用基于文本格式
​ 2、多路复用：连接共享，不同的 request 可以使用同一个连接传输（最后根据每个 request 上的 id 号组合成正常的请求）
​ 3、header 压缩：由于 1.X 中 header 带有大量的信息，并且得重复传输，2.0 使用 encoder 来减少需要传输的 hearder 大小
​ 4、服务端推送：同 google 的 SPDUY（1.0 的一种升级）一样

#### 2、HTTP 与 HTTPS 之间的区别

​ **HTTP 与 HTTPS 之间的区别：**

|              HTTP              |                   HTTPS                    |
| :----------------------------: | :----------------------------------------: |
|          默认端口 80           |           HTTPS 默认使用端口 443           |
| 明文传输、数据未加密、安全性差 |       传输过程 ssl 加密、安全性较好        |
|     响应速度快、消耗资源少     | 响应速度较慢、消耗资源多、需要用到 CA 证书 |

​ **HTTPS 链接建立的过程：**

​ 1.首先客户端先给服务器发送一个请求

​ 2.服务器发送一个 SSL 证书给客户端，内容包括：证书的发布机构、有效期、所有者、签名以及公钥

​ 3.客户端对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密算法以及对称密钥进行加密

​ 4.服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给客户端

​ 5.随后客户端和服务端就使用对称密钥进行信息传输

​ **对称加密算法：**

​ 双方持有相同的密钥，且加密速度快，典型对称加密算法：DES、AES

​ **非对称加密算法：**

​ 密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密速度较慢，典型的非对称加密算法有：RSA、DSA

#### **3、Get 和 Post 请求区别**

**HTTP 请求：**

| 方法    | 描述                                                                 |
| :------ | -------------------------------------------------------------------- |
| GET     | 向特定资源发送请求，查询数据，并返回实体                             |
| POST    | 向指定资源提交数据进行处理请求，可能会导致新的资源建立、已有资源修改 |
| PUT     | 向服务器上传新的内容                                                 |
| HEAD    | 类似 GET 请求，返回的响应中没有具体的内容，用于获取报头              |
| DELETE  | 请求服务器删除指定标识的资源                                         |
| OPTIONS | 可以用来向服务器发送请求来测试服务器的功能性                         |
| TRACE   | 回显服务器收到的请求，用于测试或诊断                                 |
| CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器              |

**get 和 Post 区别：**

|          | GET                                                                  | POST                                                         |
| -------- | -------------------------------------------------------------------- | ------------------------------------------------------------ |
| 可见性   | 数据在 URL 中对所有人可见                                            | 数据不会显示在 URL 中                                        |
| 安全性   | 与 post 相比，get 的安全性较差，因为所<br/>发送的数据是 URL 的一部分 | 安全，因为参数不会被保存在浏览器<br/>历史或 web 服务器日志中 |
| 数据长度 | 受限制，最长 2kb                                                     | 无限制                                                       |
| 编码类型 | application/x-www-form-urlencoded                                    | multipart/form-data                                          |
| 缓存     | 能被缓存                                                             | 不能被缓存                                                   |
|          |                                                                      |                                                              |

#### **4、HTTP 常见响应状态码**

​ 100：Continue --- 继续。客户端应继续其请求。

​ 200：OK --- 请求成功。一般用于 GET 与 POST 请求。

​ 301：Moved Permanently --- 永久重定向。

​ 302：Found --- 暂时重定向。

​ 400：Bad Request --- 客户端请求的语法错误，服务器无法理解。

​ 403：Forbideen --- 服务器理解请求客户端的请求，但是拒绝执行此请求。

​ 404：Not Found --- 服务器无法根据客户端的请求找到资源（网页）。

​ 500：Internal Server Error --- 服务器内部错误，无法完成请求。

​ 502：Bad Gateway --- 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。

#### **5、重定向和转发区别**

​ **重定向：redirect：**

​ 地址栏发生变化

​ 重定向可以访问其他站点（服务器）的资源

​ 重定向是两次请求。不能使用 request 对象来共享数据

​ **转发：forward：**

​ 转发地址栏路径不变

​ 转发只能访问当前服务器下的资源

​ 转发是一次请求，可以使用 request 对象共享数据

#### **6、Cookie 和 Session 区别。**

​ Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但两者有所区别：

​ Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。

​ cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行欺骗,考虑到安全应当使用 session。

​ Cookie ⼀般⽤来保存⽤户信息，Session 的主要作⽤就是通过服务端记录⽤户的状态

### **浏览器输入 URL 过程**

​ **过程：**DNS 解析、TCP 连接、发送 HTTP 请求、服务器处理请求并返回 HTTP 报文、浏览器渲染、结束

| 过程                                                                                   | 使用的协议             |
| -------------------------------------------------------------------------------------- | ---------------------- |
| 1、浏览器查找域名 DNS 的 IP 地址<br />DNS 查找过程（浏览器缓存、路由器缓存、DNS 缓存） | DNS：获取域名对应的 ip |
| 2、根据 ip 建立 TCP 连接                                                               | TCP：与服务器建立连接  |
| 3、浏览器向服务器发送 HTTP 请求                                                        | HTTP：发送请求         |
| 4、服务器响应 HTTP 响应                                                                | HTTP                   |
| 5、浏览器进行渲染                                                                      |                        |

## **操作系统基础**

### **进程和线程的区别**

​ **进程：**是资源分配的最小单位，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，不共享栈、程序计数器

​ **线程：**是任务调度和执行的最小单位，线程并行执行存在资源竞争和上下文切换的问题

​ **协程：**是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。

#### **1、进程间通信方式 IPC**

**管道 pipe：**

​ 亲缘关系使用匿名管道，非亲缘关系使用命名管道，管道遵循 FIFO，半双工，数据只能单向通信；

**信号：**

​ 信号是一种比较复杂的通信方式，用户调用 kill 命令将信号发送给其他进程。

**消息队列：**

​ 消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。

**共享内存(share memory)：**

- 使得多个进程可以可以直接读写同一块内存空间，是最快的可用 IPC 形式。是针对其他通信机制运行效率较低而设计的。
- 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。

**信号量(Semaphores) ：**

​ 信号量是⼀个计数器，⽤于多进程对共享数据的访问，这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。

**套接字(Sockets) :**

​ 简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。

#### **2、用户态和核心态**

**用户态：**只能受限的访问内存，运行所有的应用程序

**核心态：**运行操作系统程序，cpu 可以访问内存的所有数据，包括外围设备

**为什么要有用户态和内核态：**

​ 由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络

**用户态切换到内核态的 3 种方式：**

​ **a. 系统调用**

​ 主动调用，系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如 Linux 的 int 80h 中断。

​ **b. 异常**

​ 当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，比如缺页异常，这时会触发切换内核态处理异常。

​ **c. 外围设备的中断**

​ 当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会由用户态到内核态的切换。

#### **3、操作系统的进程空间**

​ 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。

​ 堆区（heap）— 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收 。

​ 静态区（static）—存放全局变量和静态变量的存储

​ 代码区(text)—存放函数体的二进制代码。

​ **线程共享堆区、静态区**

### 操作系统内存管理

**存管理方式：**页式管理、段式管理、段页式管理

**分段管理：**

​ 将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如 4k 的段换 5k 的段，会产生 1k 的外碎片）

**分页管理：**

​ 在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）

**段页式管理：**

​ 段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的

#### **1、页面置换算法 FIFO、LRU**

**置换算法：**先进先出 FIFO、最近最久未使用 LRU、最佳置换算法 OPT

**先进先出 FIFO:**

​ 缺点：没有考虑到实际的页面使用频率，性能差、与通常页面使用的规则不符合，实际应用较少

**最近最久未使用 LRU:**

​ 原理：选择最近且最久未使用的页面进行淘汰

​ 优点：考虑到了程序访问的时间局部性，有较好的性能，实际应用也比较多

​ 缺点：没有合适的算法，只有适合的算法，lFU、random 都可以

```java
/**
 * @program: Java
 * @description: LRU最近最久未使用置换算法，通过LinkedHashMap实现
 * @author: Mr.Li
 * @create: 2020-07-17 10:29
 **/
public class LRUCache {
    private LinkedHashMap<Integer,Integer> cache;
    private int capacity;   //容量大小

    /**
     *初始化构造函数
     * @param capacity
     */
    public LRUCache(int capacity) {
        cache = new LinkedHashMap<>(capacity);
        this.capacity = capacity;
    }

    public int get(int key) {
        //缓存中不存在此key，直接返回
        if(!cache.containsKey(key)) {
            return -1;
        }

        int res = cache.get(key);
        cache.remove(key);   //先从链表中删除
        cache.put(key,res);  //再把该节点放到链表末尾处
        return res;
    }

    public void put(int key,int value) {
        if(cache.containsKey(key)) {
            cache.remove(key); //已经存在，在当前链表移除
        }
        if(capacity == cache.size()) {
            //cache已满，删除链表头位置
            Set<Integer> keySet = cache.keySet();
            Iterator<Integer> iterator = keySet.iterator();
            cache.remove(iterator.next());
        }
        cache.put(key,value);  //插入到链表末尾
    }
}

```

```java
/**
 * @program: Java
 * @description: LRU最近最久未使用置换算法，通过LinkedHashMap内部removeEldestEntry方法实现
 * @author: Mr.Li
 * @create: 2020-07-17 10:59
 **/
class LRUCache {
    private Map<Integer, Integer> map;
    private int capacity;

    /**
     *初始化构造函数
     * @param capacity
     */
    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new LinkedHashMap<Integer, Integer>(capacity, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry eldest) {
                return size() > capacity;  // 容量大于capacity 时就删除
            }
        };
    }
    public int get(int key) {
        //返回key对应的value值，若不存在，返回-1
        return map.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        map.put(key, value);
    }
}
```

**最佳置换算法 OPT:**

​ 原理：每次选择当前物理块中的页面在未来长时间不被访问的或未来不再使用的页面进行淘汰

​ 优点：具有较好的性能，可以保证获得最低的缺页率

​ 缺点：过于理想化，但是实际上无法实现（没办法预知未来的页面）

#### **2、死锁条件、解决方式。**

​ 死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象；

​ **死锁的条件：**

​ 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待至占有该资源的进程释放该资源；

​ 请求与保持条件：进程获得一定的资源后，又对其他资源发出请求，阻塞过程中不会释放自己已经占有的资源

​ 非剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放

​ 循环等待条件：系统中若干进程组成环路，环路中每个进程都在等待相邻进程占用的资源

​ **解决方法：**破坏死锁的任意一条件

​ 乐观锁，破坏资源互斥条件，**CAS**

​ 资源一次性分配，从而剥夺请求和保持条件、**tryLock**

​ 可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件，**数据库 deadlock 超时**

​ 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，从而破坏环路等待的条件，**转账场景**

## **Java 基础**

### 面向对象三大特性

**特性：**封装、继承、多态

​ **封装：**对抽象的事物抽象化成一个对象，并对其对象的属性私有化，同时提供一些能被外界访问属性的方法；

​ **继承**：子类扩展新的数据域或功能，并复用父类的属性与功能，单继承，多实现；

​ **多态：**通过继承（多个⼦类对同⼀⽅法的重写）、也可以通过接⼝（实现接⼝并覆盖接⼝）

#### **1、Java 与 C++区别**

​ 不同点：c++支持多继承，并且有指针的概念，由程序员自己管理内存；Java 是单继承，可以用接口实现多继承，Java 不提供指针来直接访问内存，程序内存更加安全，并且 Java 有 JVM ⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存

#### **2、多态实现原理**

多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。

**静态绑定与动态绑定：**

​ 一种是在编译期确定，被称为静态分派，比如方法的重载；

​ 一种是在运行时确定，被称为动态分派，比如方法的覆盖（重写）和接口的实现。

**多态的实现**

​ 虚拟机栈中会存放当前方法调用的栈帧（局部变量表、操作栈、动态连接 、返回地址）。多态的实现过程，就是方法调用动态分派的过程，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。

#### 3、static 和 final 关键字

**static：**可以修饰属性、方法

​ **static 修饰属性：**

​ 类级别属性，所有对象共享一份，随着类的加载而加载（只加载一次），先于对象的创建；可以使用类名直接调用。

​ **static 修饰方法：**

​ 随着类的加载而加载；可以使用类名直接调用；静态方法中，只能调用静态的成员，不可用 this；

**final：**关键字主要⽤在三个地⽅：变量、⽅法、类。

​ **final 修饰变量：**

​ 如果是基本数据类型的变量，则其数值⼀旦在初始化之后便不能更改；

​ 如果是引⽤类型的变量，则在对其初始化之后便不能再让其指向另⼀个对象。

​ **final 修饰方法：**

​ 把⽅法锁定，以防任何继承类修改它的含义（重写）；类中所有的 private ⽅法都隐式地指定为 final。

​ **final 修饰类：**

​ final 修饰类时，表明这个类不能被继承。final 类中的所有成员⽅法都会被隐式地指定为 final ⽅法。

一个类不能被继承，除了 final 关键字之外，还有可以私有化构造器。（内部类无效）

#### 4、抽象类和接口

**抽象类：**包含抽象方法的类，即使用 abstract 修饰的类；抽象类只能被继承，所以不能使用 final 修饰，抽象类不能被实例化，

**接口：**接口是一个抽象类型，是抽象方法的集合，接口支持多继承，接口中定义的方法，默认是 public abstract 修饰的抽象方法

**相同点：**

​ ① 抽象类和接口都不能被实例化

​ ② 抽象类和接口都可以定义抽象方法，子类/实现类必须覆写这些抽象方法

**不同点：**

​ ① 抽象类有构造方法，接口没有构造方法

​ ③ 抽象类可以包含普通方法，接口中只能是 public abstract 修饰抽象方法（Java8 之后可以）

​ ③ 抽象类只能单继承，接口可以多继承

​ ④ 抽象类可以定义各种类型的成员变量，接口中只能是 public static final 修饰的静态常量

**抽象类的使用场景：**

​ 既想约束子类具有共同的行为（但不再乎其如何实现），又想拥有缺省的方法，又能拥有实例变量

**接口的应用场景：**

​ 约束多个实现类具有统一的行为，但是不在乎每个实现类如何具体实现；实现类中各个功能之间可能没有任何联系

#### 5、泛型以及泛型擦除

参考：https://blog.csdn.net/baoyinwang/article/details/107341997

**泛型：**

​ 泛型的本质是参数化类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。

**泛型擦除：**

​ Java 的泛型是伪泛型，使用泛型的时候加上类型参数，在编译器编译生成的字节码的时候会去掉，这个过程成为类型擦除。

​ 如`List<String>`等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。

可以通过反射添加其它类型元素

#### **6、反射原理以及使用场景**

**Java 反射：**

​ 是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且都能够调用它的任意一个方法；

**反射原理：**

​ 反射首先是能够获取到 Java 中的反射类的字节码，然后将字节码中的方法，变量，构造函数等映射成 相应的 Method、Filed、Constructor 等类

​ **如何得到 Class 的实例:**

1.类名.class(就是一份字节码)
2.Class.forName(String className);根据一个类的全限定名来构建 Class 对象 3.每一个对象多有 getClass()方法:obj.getClass();返回对象的真实类型

**使用场景：**

- **开发通用框架 -** 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，需要根据配置文件运行时动态加载不同的对象或类，调用不同的方法。

- **动态代理** - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。

  JDK：spring 默认动态代理，需要实现接口

  CGLIB：通过 asm 框架序列化字节流，可配置，性能差

- **自定义注解** - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。

#### **7、Java 异常体系**

![](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3137389296,1222888772&fm=26&gp=0.jpg)

Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception

**Error ：**

​ 是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。

**Exception 包含：RuntimeException 、CheckedException**

编程错误可以分成三类：语法错误、逻辑错误和运行错误。

**语法错误**（也称编译错误）是在编译过程中出现的错误，由编译器检查发现语法错误

**逻辑错误**指程序的执行结果与预期不符，可以通过调试定位并发现错误的原因

**运行错误**是引起程序非正常终端的错误，需要通过异常处理的方式处理运行错误

**RuntimeException：** 运行时异常，程序应该从逻辑角度尽可能避免这类异常的发生。

​ 如 NullPointerException 、 ClassCastException ；

**CheckedException：**受检异常，程序使用 trycatch 进行捕捉处理

​ 如 IOException、SQLException、NotFoundException；

### 数据结构

![JavaCollection](https://tva1.sinaimg.cn/large/008eGmZEly1goe17hajvzj316d0lhju3.jpg)

#### **1、ArrayList 和 LinkedList**

**ArrayList：**

​ 底层基于数组实现，支持对元素进行快速随机访问，适合随机查找和遍历，不适合插入和删除。（提一句实际上）
​ 默认初始大小为 10，当数组容量不够时，会触发扩容机制（扩大到当前的 1.5 倍），需要将原来数组的数据复制到新的数组中；当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。

**LinkedList：**

​ 底层基于双向链表实现，适合数据的动态插入和删除；
​ 内部提供了 List 接口中没有定义的方法，用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。（比如 jdk 官方推荐使用基于 linkedList 的 Deque 进行堆栈操作）

**ArrayList 与 LinkedList 区别：**

​ 都是线程不安全的，ArrayList 适用于查找的场景，LinkedList 适用于增加、删除多的场景

**实现线程安全：**

​ 可以使用原生的 Vector，或者是 Collections.synchronizedList(List list)函数返回一个线程安全的 ArrayList 集合。
​ 建议使用 concurrent 并发包下的**CopyOnWriteArrayList**的。

​ ①**Vector:** 底层通过 synchronize 修饰保证线程安全，效率较差

​ ②**CopyOnWriteArrayList：**写时加锁，使用了一种叫**写时复制**的方法；读操作是可以不用加锁的

​

#### **2、List 遍历快速和安全失败**

**① 普通 for 循环遍历 List 删除指定元素**

```java
for(int i=0; i < list.size(); i++){
   if(list.get(i) == 5)
       list.remove(i);
}
```

**② 迭代遍历,用 list.remove(i)方法删除元素**

```JAVA
Iterator<Integer> it = list.iterator();
while(it.hasNext()){
    Integer value = it.next();
    if(value == 5){
        list.remove(value);
    }
}
```

**③foreach 遍历 List 删除元素**

```JAVA
for(Integer i:list){
    if(i==3) list.remove(i);
}
```

**fail—fast：**快速失败

​ 当异常产生时，直接抛出异常，程序终止;

​ fail-fast 主要是体现在当我们在遍历集合元素的时候，经常会使用迭代器，但在迭代器遍历元素的过程中，如果集合的结构（modCount）被改变的话，就会抛出异常 ConcurrentModificationException，防止继续遍历。这就是所谓的快速失败机制。

**fail—safe：**安全失败

采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 ConcurrentModificationException。

缺点：基于拷贝内容的优点是避免了 ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。

场景：java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改。

#### **3、详细介绍 HashMap**

角度：数据结构+扩容情况+put 查找的详细过程+哈希函数+容量为什么始终都是 2^N，JDK1.7 与 1.8 的区别。

参考：https://www.jianshu.com/p/9fe4cb316c05

**数据结构：**

​ HashMap 在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据

**扩容情况：**

​ 默认的负载因子是 0.75，如果数组中已经存储的元素个数大于数组长度的 75%，将会引发扩容操作。

​ 【1】创建一个长度为原来数组长度**两倍的新数组**。

​ 【2】1.7 采用 Entry 的重新 hash 运算，1.8 采用高于与运算。

**put 操作步骤：**

​ <img src="https://s0.lgstatic.com/i/image3/M01/73/D9/CgpOIF5rDYmATP43AAB3coc0R64799.png" alt="img" style="zoom:67%;" />

​ 1、判断数组是否为空，为空进行初始化;

​ 2、不为空，则计算 key 的 hash 值，通过(n - 1) & hash 计算应当存放在数组中的下标 index;

​ 3、查看 table[index] 是否存在数据，没有数据就构造一个 Node 节点存放在 table[index] 中；

​ 4、存在数据，说明发生了 hash 冲突(存在二个节点 key 的 hash 值一样), 继续判断 key 是否相等，相等，用新的 value 替换原数据；

​ 5、若不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中；

​ 6、若不是红黑树，创建普通 Node 加入链表中；判断链表长度是否大于 8，大于则将链表转换为红黑树；

​ 7、插入完成之后判断当前节点数是否大于阈值，若大于，则扩容为原数组的二倍

**哈希函数：**

​ 通过 hash 函数（优质因子 31 循环累加）先拿到 key 的 hashcode，是一个 32 位的值，然后让 hashcode 的高 16 位和低 16 位进行**异或**操作。该函数也称为扰动函数，做到尽可能降低 hash 碰撞，通过尾插法进行插入。

**容量为什么始终都是 2^N：**

​ 先做对数组的⻓度取模运算，得到的余数才能⽤来要存放的位置也就是对应的数组下标。这个数组下标的计算⽅法是“ (n - 1) & hash ”。（n 代表数组⻓度）。方便数组的扩容和增删改时的取模。

**JDK1.7 与 1.8 的区别：**

**JDK1.7 HashMap：**

​ 底层是 **数组和链表** 结合在⼀起使⽤也就是链表散列。如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。扩容翻转时顺序不一致使用头插法会产生死循环，导致 cpu100%

**JDK1.8 HashMap：**

​ 底层数据结构上采用了**数组＋链表＋红黑树**；当链表⻓度⼤于阈值（默认为 8-泊松分布），数组的⻓度大于 64 时，链表将转化为红⿊树，以减少搜索时间。（解决了 tomcat 臭名昭著的 url 参数 dos 攻击问题）

#### **4、ConcurrentHashMap **

​ 可以通过**ConcurrentHashMap** 和 **Hashtable**来实现线程安全；Hashtable 是原始 API 类，通过 synchronize 同步修饰，效率低下；ConcurrentHashMap 通过分段锁实现，效率较比 Hashtable 要好；

**ConcurrentHashMap 的底层实现：**

​ **JDK1.7 的 ConcurrentHashMap** 底层采⽤ 分段的数组+链表 实现；采用 **分段锁**（Sagment） 对整个桶数组进⾏了分割分段(Segment 默认 16 个)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。

![](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1035283471,1167301443&fm=26&gp=0.jpg)

​ **JDK1.8 的 ConcurrentHashMap** 采⽤的数据结构跟 HashMap1.8 的结构⼀样，数组+链表/红⿊树；摒弃了 Segment 的概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，通过并发控制 **synchronized 和 CAS**来操作保证线程的安全。

#### **5、序列化和反序列化**

​ 序列化的意思就是将对象的状态转化成字节流，以后可以通过这些值再生成相同状态的对象。对象序列化是对象持久化的一种实现方法，它是将对象的属性和方法转化为一种序列化的形式用于存储和传输。反序列化就是根据这些保存的信息重建对象的过程。

**序列化：**将 java 对象转化为字节序列的过程。

**反序列化：**将字节序列转化为 java 对象的过程。

**优点：**

​ a、实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里）Redis 的 RDB

​ b、利用序列化实现远程通信，即在网络上传送对象的字节序列。 Google 的 protoBuf

**反序列化失败的场景：**

​ 序列化 ID：serialVersionUID 不一致的时候，导致反序列化失败

#### **6、String**

String 使用**数组**存储内容，数组使用 **final** 修饰，因此 String 定义的字符串的值也是**不可变的**

StringBuffer 对方法加了同步锁，线程安全，效率略低于 StringBuilder

### 设计模式与原则

#### 1、单例模式

​ 某个类只能生成一个实例，该实例全局访问，例如 Spring 容器里一级缓存里的单例池。

**优点**：

​ **唯一访问**：如生成唯一序列化的场景、或者 spring 默认的 bean 类型。

​ **提高性能**：频繁实例化创建销毁或者耗时耗资源的场景，如连接池、线程池。

**缺点**：

​ 不适合有状态且需变更的

**实现方式**：

​ **饿汉式**：线程安全速度快

​ **懒汉式**：双重检测锁，第一次减少锁的开销、第二次防止重复、volatile 防止重排序导致实例化未完成

​ **静态内部类**：线程安全利用率高

​ **枚举**：effictiveJAVA 推荐，反射也无法破坏

#### 2、工厂模式

​ 定义一个用于创建产品的接口，由子类决定生产何种产品。

**优点：**解耦：提供参数即可获取产品，通过配置文件可以不修改代码增加具体产品。

**缺点：**每增加一个产品就得新增一个产品类

#### 3、抽象工厂模式

​ 提供一个接口，用于创建相关或者依赖对象的家族，并由此进行约束。

**优点：**可以在类的内部对产品族进行约束

**缺点**：假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。

## 面试题

### 构造方法

构造方法可以被重载，只有当类中没有显性声明任何构造方法时，才会有默认构造方法。

构造方法没有返回值，构造方法的作用是创建新对象。

### 初始化块

静态初始化块的优先级最高，会最先执行，在非静态初始化块之前执行。

静态初始化块会在类第一次被加载时最先执行，因此在 main 方法之前。

### This

关键字 `this` 代表当前对象的引用。当前对象指的是调用类中的属性或方法的对象

关键字 `this` 不可以在静态方法中使用。静态方法不依赖于类的具体对象的引用

### **重写和重载的区别**

重载指在同一个类中定义多个方法，这些方法名称相同，签名不同。

重写指在子类中的方法的名称和签名都和父类相同，使用 override 注解

### Object 类方法

**toString** 默认是个指针，一般需要重写

**equals** 比较对象是否相同，默认和==功能一致

**hashCode** 散列码，equals 则 hashCode 相同，所以重写 equals 必须重写 hashCode

**finalize ** 用于垃圾回收之前做的遗嘱，默认空，子类需重写

**clone** 深拷贝，类需实现 cloneable 的接口

**getClass** 反射获取对象元数据，包括类名、方法、

**notify、wait** 用于线程通知和唤醒

### 基本数据类型和包装类

![image-20210309224910999](https://tva1.sinaimg.cn/large/008eGmZEly1goe1gq2yipj318s0ruwj4.jpg)

| 类型                    | 缓存范围      |
| ----------------------- | ------------- |
| Byte,Short,Integer,Long | [-128, 127]   |
| Character               | [0, 127]      |
| Boolean                 | [false, true] |
