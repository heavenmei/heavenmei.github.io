[
  {
    "title": "ubuntu环境配置",
    "url": "/2023-11-25-one-step-install",
    "description": "装环境实在太麻烦啦，mark一些安装命令，以备不时之需。",
    "date": "2023-11-25T00:00:00.000Z",
    "body": {
      "raw": "\n\n>  装环境实在太麻烦啦，mark一些安装命令，以备不时之需。\n>  一键化自动安装脚本（Both for Mac & Ubuntu）： https://github.com/heavenmei/one-step-install\n## 1、系统安装\n\nubuntu分配桌面版和服务器版，在主机上安装桌面版\n\n1. 下载镜像链接 https://releases.ubuntu.com/\n2. mac使用etcher烧录到U盘： [https://etcher.balena.io/](https://etcher.balena.io/)![Untitled.png](https://raw.githubusercontent.com/heavenmei/heavenmei.github.io/master/images/202312112004610.png)\n3. f2 进入bios界面，设置u盘启动\n4. 按照界面提示安装ubuntu，最重要是分区\n\n\n\n## 2、显卡驱动\n\n下载显卡驱动：[https://www.nvidia.com/Download/index.aspx?lang=en-us](https://www.nvidia.com/Download/index.aspx?lang=en-us)\n\n\n\n## 3、Clash\n\n下载文件 `clash-linux-amd64-v1.17.0.gz`\n> 链接: https://pan.baidu.com/s/1RzYl_CGHLF9IUS9I5xyvZg?pwd=53kc 提取码: 53kc\n\n解压：`gunzip clash-linux-amd64-v1.17.0.gz`\n移动重命名： `sudo mv clash-linux-amd64-v1.17.0 /usr/local/bin/clash`\n给 Clash 添加执行权限：`sudo chmod +x /usr/local/bin/clash`\n启动 Clash自动创建initial config file：`clash -d ~/.config/clash`\n替换订阅文件：`curl https:/xxxx.yaml > ~/.config/clash/config.yaml`（或者手动复制）\n启动 Clash：`clash -d ~/.config/clash`\n写入 ~/zshrc\n\n```json\necho 'export http_proxy=127.0.0.1:7890' >> ~/.zshrc\necho 'export https_proxy=$http_proxy' >> ~/.zshrc\n```\n\n**开机自启配置：**[https://blog.csdn.net/xiaxinkai/article/details/123563488](https://blog.csdn.net/xiaxinkai/article/details/123563488)\n\n`sudo vim /etc/systemd/system/clash.service`\n\n写入配置\n\n```json\n[Unit]\nDescription=clash service\nAfter=network.target\n \n[Service]\nExecStart=/usr/local/bin/clash -d /home/haiwen/.config/clash/\n \n[Install]\nWantedBy=multi-user.target\n```\n\n`sudo systemctl daemon-reload # 刷新配置` `sudo systemctl start clash # 启动clash.service` `sudo systemctl enable clash # 设置开机启动` `sudo systemctl status clash # 查看clash.service的状态`\n\n## 3、一键配置脚本\n\n下载一键安装脚本，执行`xxx/one_step_install.sh`\n\n### oh-my-zsh\n\n1. `zsh xxx/one_step_install.sh`, 选择ohmyzsh\n\n2. 重启终端，配置主题\n    \n\n如果安装卡住，可能是网络不好 解决1：`zsh one_step_install.sh`, 选择scientific_surfing，再次安装\n\n解决2: 先装clash，科学上网\n\n解决3：直接 `zsh install_ohmyzsh.sh`,但是没有主题配置\n\n查看终端：`echo $SHELL`\n\n若不是zsh，请手动配置：`chsh -s $(which zsh)`，重启后可切换\n\n### nvm & node\n\n默认安装nvm，及node 16.20.0\n\n![](https://raw.githubusercontent.com/heavenmei/heavenmei.github.io/master/images/202312112015109.png)\n\n### ssh\n\n配置端口号\n\n查看ip: `ip a`\n\n查看port: `/etc/ssh/sshd-config`\n\n之后可以在本机电脑 ssh username@ip -p PORT 远程连接\n\n### docker\nhttps://www.runoob.com/docker/docker-container-connection.html\n\nfor ubuntu20+\n\n[Ubuntu中docker的安装和使用_ubuntu docker_urnotlanxi的博客-CSDN博客](https://blog.csdn.net/urnotlanxi/article/details/128005616)\n\n\n### conda\n```shell\n# download\ncurl -O https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh\n# 安装\nsudo bash ./Anaconda3-5.2.0-Linux-x86_64.sh \n# 添加环境变量 \necho 'export PATH=~/anaconda3/bin:$PATH' >> ~/.bashrc \n# 刷新bashrc\nsource ~/.bashrc \n```\n\n\n## QA\n##### Q: sudo: command not found\n`apt install sudo`\n\n##### Q：apt & apt-get\n_apt_ 和 _apt-get_ 之间的区别不仅在于 _apt_ 是 _apt-get_ 的较新版本。_apt_ 命令被设计为对用户更加友好的 _apt-get_ 替代方案，结合了多个包管理工具的功能，为用户提供便利。\n[APT 与 APT-GET 之间有什么区别？](https://aws.amazon.com/cn/compare/the-difference-between-apt-and-apt-get/)",
      "html": "<blockquote>\n<p>装环境实在太麻烦啦，mark一些安装命令，以备不时之需。\n一键化自动安装脚本（Both for Mac &#x26; Ubuntu）： https://github.com/heavenmei/one-step-install</p>\n</blockquote>\n<h2>1、系统安装</h2>\n<p>ubuntu分配桌面版和服务器版，在主机上安装桌面版</p>\n<ol>\n<li>下载镜像链接 https://releases.ubuntu.com/</li>\n<li>mac使用etcher烧录到U盘： <a href=\"https://etcher.balena.io/\">https://etcher.balena.io/</a><img src=\"https://raw.githubusercontent.com/heavenmei/heavenmei.github.io/master/images/202312112004610.png\" alt=\"Untitled.png\"></li>\n<li>f2 进入bios界面，设置u盘启动</li>\n<li>按照界面提示安装ubuntu，最重要是分区</li>\n</ol>\n<h2>2、显卡驱动</h2>\n<p>下载显卡驱动：<a href=\"https://www.nvidia.com/Download/index.aspx?lang=en-us\">https://www.nvidia.com/Download/index.aspx?lang=en-us</a></p>\n<h2>3、Clash</h2>\n<p>下载文件 <code>clash-linux-amd64-v1.17.0.gz</code></p>\n<blockquote>\n<p>链接: https://pan.baidu.com/s/1RzYl_CGHLF9IUS9I5xyvZg?pwd=53kc 提取码: 53kc</p>\n</blockquote>\n<p>解压：<code>gunzip clash-linux-amd64-v1.17.0.gz</code>\n移动重命名： <code>sudo mv clash-linux-amd64-v1.17.0 /usr/local/bin/clash</code>\n给 Clash 添加执行权限：<code>sudo chmod +x /usr/local/bin/clash</code>\n启动 Clash自动创建initial config file：<code>clash -d ~/.config/clash</code>\n替换订阅文件：<code>curl https:/xxxx.yaml > ~/.config/clash/config.yaml</code>（或者手动复制）\n启动 Clash：<code>clash -d ~/.config/clash</code>\n写入 ~/zshrc</p>\n<pre><code class=\"language-json\">echo 'export http_proxy=127.0.0.1:7890' >> ~/.zshrc\necho 'export https_proxy=$http_proxy' >> ~/.zshrc\n</code></pre>\n<p><strong>开机自启配置：</strong><a href=\"https://blog.csdn.net/xiaxinkai/article/details/123563488\">https://blog.csdn.net/xiaxinkai/article/details/123563488</a></p>\n<p><code>sudo vim /etc/systemd/system/clash.service</code></p>\n<p>写入配置</p>\n<pre><code class=\"language-json\">[Unit]\nDescription=clash service\nAfter=network.target\n \n[Service]\nExecStart=/usr/local/bin/clash -d /home/haiwen/.config/clash/\n \n[Install]\nWantedBy=multi-user.target\n</code></pre>\n<p><code>sudo systemctl daemon-reload # 刷新配置</code> <code>sudo systemctl start clash # 启动clash.service</code> <code>sudo systemctl enable clash # 设置开机启动</code> <code>sudo systemctl status clash # 查看clash.service的状态</code></p>\n<h2>3、一键配置脚本</h2>\n<p>下载一键安装脚本，执行<code>xxx/one_step_install.sh</code></p>\n<h3>oh-my-zsh</h3>\n<ol>\n<li>\n<p><code>zsh xxx/one_step_install.sh</code>, 选择ohmyzsh</p>\n</li>\n<li>\n<p>重启终端，配置主题</p>\n</li>\n</ol>\n<p>如果安装卡住，可能是网络不好 解决1：<code>zsh one_step_install.sh</code>, 选择scientific_surfing，再次安装</p>\n<p>解决2: 先装clash，科学上网</p>\n<p>解决3：直接 <code>zsh install_ohmyzsh.sh</code>,但是没有主题配置</p>\n<p>查看终端：<code>echo $SHELL</code></p>\n<p>若不是zsh，请手动配置：<code>chsh -s $(which zsh)</code>，重启后可切换</p>\n<h3>nvm &#x26; node</h3>\n<p>默认安装nvm，及node 16.20.0</p>\n<p><img src=\"https://raw.githubusercontent.com/heavenmei/heavenmei.github.io/master/images/202312112015109.png\" alt=\"\"></p>\n<h3>ssh</h3>\n<p>配置端口号</p>\n<p>查看ip: <code>ip a</code></p>\n<p>查看port: <code>/etc/ssh/sshd-config</code></p>\n<p>之后可以在本机电脑 ssh username@ip -p PORT 远程连接</p>\n<h3>docker</h3>\n<p>https://www.runoob.com/docker/docker-container-connection.html</p>\n<p>for ubuntu20+</p>\n<p><a href=\"https://blog.csdn.net/urnotlanxi/article/details/128005616\">Ubuntu中docker的安装和使用_ubuntu docker_urnotlanxi的博客-CSDN博客</a></p>\n<h3>conda</h3>\n<pre><code class=\"language-shell\"># download\ncurl -O https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh\n# 安装\nsudo bash ./Anaconda3-5.2.0-Linux-x86_64.sh \n# 添加环境变量 \necho 'export PATH=~/anaconda3/bin:$PATH' >> ~/.bashrc \n# 刷新bashrc\nsource ~/.bashrc \n</code></pre>\n<h2>QA</h2>\n<h5>Q: sudo: command not found</h5>\n<p><code>apt install sudo</code></p>\n<h5>Q：apt &#x26; apt-get</h5>\n<p><em>apt</em> 和 <em>apt-get</em> 之间的区别不仅在于 <em>apt</em> 是 <em>apt-get</em> 的较新版本。<em>apt</em> 命令被设计为对用户更加友好的 <em>apt-get</em> 替代方案，结合了多个包管理工具的功能，为用户提供便利。\n<a href=\"https://aws.amazon.com/cn/compare/the-difference-between-apt-and-apt-get/\">APT 与 APT-GET 之间有什么区别？</a></p>"
    },
    "_id": "post/2023-11-25-ubuntu-environment.md",
    "_raw": {
      "sourceFilePath": "post/2023-11-25-ubuntu-environment.md",
      "sourceFileName": "2023-11-25-ubuntu-environment.md",
      "sourceFileDir": "post",
      "contentType": "markdown",
      "flattenedPath": "post/2023-11-25-ubuntu-environment"
    },
    "type": "Post",
    "id": ""
  },
  {
    "title": "搭建React+TS项目的几种方式",
    "url": "/2023-11-26-react+ts",
    "description": null,
    "date": "2023-11-26T00:00:00.000Z",
    "body": {
      "raw": "\n## 打包工具\n### webpack\nhttps://webpack.js.org/\n\n### Vite\nhttps://cn.vitejs.dev/\n\n取代webpck的快速构建工具，优化构建时间。使用 esbuild\n```shell\n\nnpm create vite@latest\nyarn create vite\n```\n\n\n\n## 包管理器\nnpm, yarn, bnpm\n\n\n**cross-env**\n```json\n// package.json\n\"dev\": \"cross-env PORT=9000 nuxt dev \",\n\"mock\": \"cross-env PORT=9000 MODE=mock nuxt dev \",\n```\n\n## React手脚架\n### CRA/CRACO\n\n[cra](https://create-react-app.dev/)= Create React App。基于webpack和Babel， webpack配置太多。\n\n[craco](https://craco.js.org/docs/getting-started/)= Create React App Configuration Overide。基于cra之上的一个hacky层，用于定制它的配置,allows you to get all of the benefits of Create React App without ejecting\n\n1. `npx create-react-app my-app`\n2. `npm i -D @craco/craco` or `npm i -D @craco/types`(ts)\n3. create configuaration file `craco.config.js`\n4. update `package.json`\n    \n    ```json\n    \"scripts\": {\n    -  \"start\": \"react-scripts start\"\n    +  \"start\": \"craco start\"\n    -  \"build\": \"react-scripts build\"\n    +  \"build\": \"craco build\"\n    -  \"test\": \"react-scripts test\"\n    +  \"test\": \"craco test\"\n    }\n    ```\n    \n\n\n### Next.js\n\nNext.js 是一个基于 React 的[服务端渲染框架](https://cloud.tencent.com/product/ssr?from_column=20065&from=20065)，它提供了约定式路由、多种渲染方式、静态导出等功能。\n\n**渲染方式**\n\n- CSR - 客户端渲染。也就是我们常说的 SPA（single page application），使用 `useEffect` 获取接口数据。\n- SSR - 服务器端渲染\n- SSG - 静态站点生成。\n- ISR – 增量静态再生，可以再次从 API 获取数据，并且生成静态页面，最适合常见的资讯类、新闻类网站。\n- Server component- 也是 SSR 的一种， 但互补了 SSR 的不足，让网页拥有流式渲染的能力。/CRACO（Webpack）\n\n[cra](https://create-react-app.dev/)= Create React App。基于webpack和Babel， webpack配置太多。\n\n[craco](https://craco.js.org/docs/getting-started/)= Create React App Configuration Overide。基于cra之上的一个hacky层，用于定制它的配置,allows you to get all of the benefits of Create React App without ejecting\n\n1. `npx create-react-app my-app`\n    \n2. `npm i -D @craco/craco` or `npm i -D @craco/types`(ts)\n    \n3. create configuaration file `craco.config.js`\n    \n4. update `package.json`\n    \n    ```json\n    \"scripts\": {\n    -  \"start\": \"react-scripts start\"\n    +  \"start\": \"craco start\"\n    -  \"build\": \"react-scripts build\"\n    +  \"build\": \"craco build\"\n    -  \"test\": \"react-scripts test\"\n    +  \"test\": \"craco test\"\n    }\n    ```\n    \n\n\n## Vue手脚架\n### nuxtjs\nhttps://nuxt.com/\n\n## Eslint & ts\n### ts 别名设置\n`yarn add -D @type/node`\nvite.config.ts\n```ts\nexport default defineConfig({\n  ...,\n  resolve: {\n    alias: {\n      \"~\": path.resolve(__dirname, \"./\"),\n      \"@\": path.resolve(__dirname, \"./src\"),\n    },\n  },\n});\n\n```\n\ntsconfig.json\n```json\n{\n  \"compilerOptions\": {\n    ...,\n    \"paths\": {\n      \"~/*\": [\"./*\"],\n      \"@/*\": [\"./src/*\"]\n    }\n  },\n}\n\n```\n\n\n### 禁用any\n\n```js\n//  .eslintrc (tslintrc) file :\nrules: {\n    \"@typescript-eslint/no-explicit-any\": \"off\"\n  },\n```\n\n## 辅助\ntailwindcss： https://tailwindcss.com/\nanimate.css: https://animate.style/\nchroma: https://gka.github.io/chroma.js/ (color util)\n## UI\narco.design: https://arco.design/\n",
      "html": "<h2>打包工具</h2>\n<h3>webpack</h3>\n<p>https://webpack.js.org/</p>\n<h3>Vite</h3>\n<p>https://cn.vitejs.dev/</p>\n<p>取代webpck的快速构建工具，优化构建时间。使用 esbuild</p>\n<pre><code class=\"language-shell\">\nnpm create vite@latest\nyarn create vite\n</code></pre>\n<h2>包管理器</h2>\n<p>npm, yarn, bnpm</p>\n<p><strong>cross-env</strong></p>\n<pre><code class=\"language-json\">// package.json\n\"dev\": \"cross-env PORT=9000 nuxt dev \",\n\"mock\": \"cross-env PORT=9000 MODE=mock nuxt dev \",\n</code></pre>\n<h2>React手脚架</h2>\n<h3>CRA/CRACO</h3>\n<p><a href=\"https://create-react-app.dev/\">cra</a>= Create React App。基于webpack和Babel， webpack配置太多。</p>\n<p><a href=\"https://craco.js.org/docs/getting-started/\">craco</a>= Create React App Configuration Overide。基于cra之上的一个hacky层，用于定制它的配置,allows you to get all of the benefits of Create React App without ejecting</p>\n<ol>\n<li>\n<p><code>npx create-react-app my-app</code></p>\n</li>\n<li>\n<p><code>npm i -D @craco/craco</code> or <code>npm i -D @craco/types</code>(ts)</p>\n</li>\n<li>\n<p>create configuaration file <code>craco.config.js</code></p>\n</li>\n<li>\n<p>update <code>package.json</code></p>\n<pre><code class=\"language-json\">\"scripts\": {\n-  \"start\": \"react-scripts start\"\n+  \"start\": \"craco start\"\n-  \"build\": \"react-scripts build\"\n+  \"build\": \"craco build\"\n-  \"test\": \"react-scripts test\"\n+  \"test\": \"craco test\"\n}\n</code></pre>\n</li>\n</ol>\n<h3>Next.js</h3>\n<p>Next.js 是一个基于 React 的<a href=\"https://cloud.tencent.com/product/ssr?from_column=20065&#x26;from=20065\">服务端渲染框架</a>，它提供了约定式路由、多种渲染方式、静态导出等功能。</p>\n<p><strong>渲染方式</strong></p>\n<ul>\n<li>CSR - 客户端渲染。也就是我们常说的 SPA（single page application），使用 <code>useEffect</code> 获取接口数据。</li>\n<li>SSR - 服务器端渲染</li>\n<li>SSG - 静态站点生成。</li>\n<li>ISR – 增量静态再生，可以再次从 API 获取数据，并且生成静态页面，最适合常见的资讯类、新闻类网站。</li>\n<li>Server component- 也是 SSR 的一种， 但互补了 SSR 的不足，让网页拥有流式渲染的能力。/CRACO（Webpack）</li>\n</ul>\n<p><a href=\"https://create-react-app.dev/\">cra</a>= Create React App。基于webpack和Babel， webpack配置太多。</p>\n<p><a href=\"https://craco.js.org/docs/getting-started/\">craco</a>= Create React App Configuration Overide。基于cra之上的一个hacky层，用于定制它的配置,allows you to get all of the benefits of Create React App without ejecting</p>\n<ol>\n<li>\n<p><code>npx create-react-app my-app</code></p>\n</li>\n<li>\n<p><code>npm i -D @craco/craco</code> or <code>npm i -D @craco/types</code>(ts)</p>\n</li>\n<li>\n<p>create configuaration file <code>craco.config.js</code></p>\n</li>\n<li>\n<p>update <code>package.json</code></p>\n<pre><code class=\"language-json\">\"scripts\": {\n-  \"start\": \"react-scripts start\"\n+  \"start\": \"craco start\"\n-  \"build\": \"react-scripts build\"\n+  \"build\": \"craco build\"\n-  \"test\": \"react-scripts test\"\n+  \"test\": \"craco test\"\n}\n</code></pre>\n</li>\n</ol>\n<h2>Vue手脚架</h2>\n<h3>nuxtjs</h3>\n<p>https://nuxt.com/</p>\n<h2>Eslint &#x26; ts</h2>\n<h3>ts 别名设置</h3>\n<p><code>yarn add -D @type/node</code>\nvite.config.ts</p>\n<pre><code class=\"language-ts\">export default defineConfig({\n  ...,\n  resolve: {\n    alias: {\n      \"~\": path.resolve(__dirname, \"./\"),\n      \"@\": path.resolve(__dirname, \"./src\"),\n    },\n  },\n});\n\n</code></pre>\n<p>tsconfig.json</p>\n<pre><code class=\"language-json\">{\n  \"compilerOptions\": {\n    ...,\n    \"paths\": {\n      \"~/*\": [\"./*\"],\n      \"@/*\": [\"./src/*\"]\n    }\n  },\n}\n\n</code></pre>\n<h3>禁用any</h3>\n<pre><code class=\"language-js\">//  .eslintrc (tslintrc) file :\nrules: {\n    \"@typescript-eslint/no-explicit-any\": \"off\"\n  },\n</code></pre>\n<h2>辅助</h2>\n<p>tailwindcss： https://tailwindcss.com/\nanimate.css: https://animate.style/\nchroma: https://gka.github.io/chroma.js/ (color util)</p>\n<h2>UI</h2>\n<p>arco.design: https://arco.design/</p>"
    },
    "_id": "post/2023-11-26-前端技术栈总览.md",
    "_raw": {
      "sourceFilePath": "post/2023-11-26-前端技术栈总览.md",
      "sourceFileName": "2023-11-26-前端技术栈总览.md",
      "sourceFileDir": "post",
      "contentType": "markdown",
      "flattenedPath": "post/2023-11-26-前端技术栈总览"
    },
    "type": "Post",
    "id": ""
  },
  {
    "title": "vite+vue+ts+sass项目搭建",
    "url": "/2023-11-27-vite+vue",
    "description": null,
    "date": "2023-11-27T00:00:00.000Z",
    "body": {
      "raw": "\n\n\n> 兼容性：Vite 需要 [Node.js](https://nodejs.org/en/) 版本 18+，20+\n> 若用vscode开发不要装vetur插件（垃圾），安装Volar+TypeScript Vue Plugin (Volar)（vetur的升级版）\n\n```shell\nnpm create vite my-vue-app --template vue-ts\n```\n\n\n\n> 相关依赖\n>\n> sass： `npm i sass -D`\n>\n> hooks： \n\n#### Sass\n\n```bash\nnpm i sass -D\n```\n\n全局引入： 在vite.config.js文件添加配置\n\n```js\nexport default defineConfig({\n    ...\n    css: {\n        preprocessorOptions: {\n            additionalData: '@import \"@/assets/scss/globalVar.scss\";@import \"@/assets/scss/globalMixin.scss\";'\n        }\n    }\n});\n```\n\n按需引入\n\n```vue\n<style lang=\"scss\" scoped>\n    @import \"@/assets/scss/globalVar.scss\";\n</style>\n```\n\n\n\n#### 路径别名\n\n```shell\nnpm install @types/node --save-dev\n```\n\n配置vite.config.ts\n\n```tsx\nimport path from \"path\";\n\nexport default defineConfig({\n  ...\n  resolve: {\n    alias: {\n      \"@\": path.resolve(\"./src\"),\n    },\n  },\n});\n\n```\n\n配置tsconfig.json\n\n```tsx\n{\n  \"compilerOptions\": {\n    ...\n    \"baseUrl\": \".\",\n    \"paths\": { \"@/*\": [\"src/*\"] }\n  },\n}\n```\n\n\n\n#### 状态管理-Pinia\n\n[pinia](https://pinia.vuejs.org/zh/)\n[pinia-plugin-persist](https://seb-l.github.io/pinia-plugin-persist/)\n\n```bash\nnpm install pinia -D\nnpm install pinia-plugin-persist -D # 可选，插件\n```\n\n\n\n#### 多环境配置\n\n添加配置文件\n\n```shell\n# .env.user\n# 接口请求地址前缀\nVITE_APP_API_PREFIX = /api\n\n# 删除 console 代码\nVITE_DROP_CONSOLE = true\n\n# 生产环境配置文件名称\nVITE_GLOB_CONFIG_FILE_NAME = app.config.js\n\n# 打包生成目录\nVITE_OUTPUT_DIR = user\n\n# 平台\nVITE_PLATFORM = user\n\n# 重定向路径\nVITE_REDIRECT_INDEX = \"/index\"\n\n```\n\n修改package.json, 添加--mode 参数\n\n```json\n{\n  ...\n\t\"scripts\": {\n    \"dev\": \"vite  --mode dev\",\n    \"build\": \"vue-tsc && vite build --mode prd\",\n    \"preview\": \"vite preview\"\n  },\n}\n```\n\n项目中使用\n\n```js\nconst baseUrl = import.meta.env.VITE_APP_API_PREFIX;\n```\n\n\n\n## 遇到的问题\n\n##### Cannot find module 'vue'. Did you mean to set the 'moduleResolution' option to 'node', or to add aliases to the 'paths' option?Vetur\n\n把tsconfig.json配置项moduleResolution：\"bundler\"改为 moduleResolution：\"node\"\n\n\n\n##### An import path cannot end with a '.ts' extension. Consider importing '@/store/counter.js\n\n配置vite.config.ts中resolve.extensions的配置项\n\n##### Cannot find module '~/store/counter' or its corresponding type declarations.ts(2307)\n\n****\n\n\n\nhttps://juejin.cn/post/7170746000112353293?searchId=2023112613400612F6DE1AB312141A1338#heading-31\n\n\n\n服务器端口无法访问\n\nA：防火墙未开启\n\n查看防火墙中允许被访问的端口号：sudo firewall-cmd --list-all （ports选项）\n\n`firewall-cmd --zone=public --list-ports`\n\n开启端口：sudo firewall-cmd --zone=public --add-port=8887/tcp --permanent\n\n重启防火墙：sudo firewall-cmd --reload\n\n关闭端口：sudo firewall-cmd --zone=public --remove-port=7890/tcp --permanent \n\n再次检查\n\n检查端口网站：https://tool.chinaz.com/port",
      "html": "<blockquote>\n<p>兼容性：Vite 需要 <a href=\"https://nodejs.org/en/\">Node.js</a> 版本 18+，20+\n若用vscode开发不要装vetur插件（垃圾），安装Volar+TypeScript Vue Plugin (Volar)（vetur的升级版）</p>\n</blockquote>\n<pre><code class=\"language-shell\">npm create vite my-vue-app --template vue-ts\n</code></pre>\n<blockquote>\n<p>相关依赖</p>\n<p>sass： <code>npm i sass -D</code></p>\n<p>hooks：</p>\n</blockquote>\n<h4>Sass</h4>\n<pre><code class=\"language-bash\">npm i sass -D\n</code></pre>\n<p>全局引入： 在vite.config.js文件添加配置</p>\n<pre><code class=\"language-js\">export default defineConfig({\n    ...\n    css: {\n        preprocessorOptions: {\n            additionalData: '@import \"@/assets/scss/globalVar.scss\";@import \"@/assets/scss/globalMixin.scss\";'\n        }\n    }\n});\n</code></pre>\n<p>按需引入</p>\n<pre><code class=\"language-vue\">&#x3C;style lang=\"scss\" scoped>\n    @import \"@/assets/scss/globalVar.scss\";\n&#x3C;/style>\n</code></pre>\n<h4>路径别名</h4>\n<pre><code class=\"language-shell\">npm install @types/node --save-dev\n</code></pre>\n<p>配置vite.config.ts</p>\n<pre><code class=\"language-tsx\">import path from \"path\";\n\nexport default defineConfig({\n  ...\n  resolve: {\n    alias: {\n      \"@\": path.resolve(\"./src\"),\n    },\n  },\n});\n\n</code></pre>\n<p>配置tsconfig.json</p>\n<pre><code class=\"language-tsx\">{\n  \"compilerOptions\": {\n    ...\n    \"baseUrl\": \".\",\n    \"paths\": { \"@/*\": [\"src/*\"] }\n  },\n}\n</code></pre>\n<h4>状态管理-Pinia</h4>\n<p><a href=\"https://pinia.vuejs.org/zh/\">pinia</a>\n<a href=\"https://seb-l.github.io/pinia-plugin-persist/\">pinia-plugin-persist</a></p>\n<pre><code class=\"language-bash\">npm install pinia -D\nnpm install pinia-plugin-persist -D # 可选，插件\n</code></pre>\n<h4>多环境配置</h4>\n<p>添加配置文件</p>\n<pre><code class=\"language-shell\"># .env.user\n# 接口请求地址前缀\nVITE_APP_API_PREFIX = /api\n\n# 删除 console 代码\nVITE_DROP_CONSOLE = true\n\n# 生产环境配置文件名称\nVITE_GLOB_CONFIG_FILE_NAME = app.config.js\n\n# 打包生成目录\nVITE_OUTPUT_DIR = user\n\n# 平台\nVITE_PLATFORM = user\n\n# 重定向路径\nVITE_REDIRECT_INDEX = \"/index\"\n\n</code></pre>\n<p>修改package.json, 添加--mode 参数</p>\n<pre><code class=\"language-json\">{\n  ...\n\t\"scripts\": {\n    \"dev\": \"vite  --mode dev\",\n    \"build\": \"vue-tsc &#x26;&#x26; vite build --mode prd\",\n    \"preview\": \"vite preview\"\n  },\n}\n</code></pre>\n<p>项目中使用</p>\n<pre><code class=\"language-js\">const baseUrl = import.meta.env.VITE_APP_API_PREFIX;\n</code></pre>\n<h2>遇到的问题</h2>\n<h5>Cannot find module 'vue'. Did you mean to set the 'moduleResolution' option to 'node', or to add aliases to the 'paths' option?Vetur</h5>\n<p>把tsconfig.json配置项moduleResolution：\"bundler\"改为 moduleResolution：\"node\"</p>\n<h5>An import path cannot end with a '.ts' extension. Consider importing '@/store/counter.js</h5>\n<p>配置vite.config.ts中resolve.extensions的配置项</p>\n<h5>Cannot find module '~/store/counter' or its corresponding type declarations.ts(2307)</h5>\n<hr>\n<p>https://juejin.cn/post/7170746000112353293?searchId=2023112613400612F6DE1AB312141A1338#heading-31</p>\n<p>服务器端口无法访问</p>\n<p>A：防火墙未开启</p>\n<p>查看防火墙中允许被访问的端口号：sudo firewall-cmd --list-all （ports选项）</p>\n<p><code>firewall-cmd --zone=public --list-ports</code></p>\n<p>开启端口：sudo firewall-cmd --zone=public --add-port=8887/tcp --permanent</p>\n<p>重启防火墙：sudo firewall-cmd --reload</p>\n<p>关闭端口：sudo firewall-cmd --zone=public --remove-port=7890/tcp --permanent</p>\n<p>再次检查</p>\n<p>检查端口网站：https://tool.chinaz.com/port</p>"
    },
    "_id": "post/2023-11-27-vite+vue.md",
    "_raw": {
      "sourceFilePath": "post/2023-11-27-vite+vue.md",
      "sourceFileName": "2023-11-27-vite+vue.md",
      "sourceFileDir": "post",
      "contentType": "markdown",
      "flattenedPath": "post/2023-11-27-vite+vue"
    },
    "type": "Post",
    "id": ""
  },
  {
    "title": "时序数据处理学习",
    "url": "/2023-11-28-Time-series-data",
    "description": null,
    "date": "2023-11-28T00:00:00.000Z",
    "body": {
      "raw": "# Time-series-data\n\n## 1. How To Pre-Process Time Series Data\n\n[https://365datascience.com/tutorials/time-series-analysis-tutorials/](https://365datascience.com/tutorials/time-series-analysis-tutorials/)\n\n### Summary\n\n- `to_datetime`: string2date\n- `set_index`: date instead of index\n- `isna().sum()`: check NAN\n- `fillna`: fill no data\n- `asfreq`: set frequency\n\n## 2. What Is an Autoregressive Model? (AR Model)\n\nThe Autoregressive Model, or AR model for short, relies only on past period values to predict current ones. It’s a linear model, where current period values are a sum of past outcomes multiplied by a numeric factor. We denote it as AR(p), where “p” is called the order of the model and represents the number of lagged values we want to include. For instance, if we take X as time-series variable, then an AR(1), also known as a simple autoregressive model, would look something like this:\n\n$$ X_t=C+ {\\phi}_1X_{t-1}+{\\epsilon}_t $$\n\n- ${\\phi}_1$ you can interpret it as the part of the previous value which remains in the future. It’s good to note that these coefficients should always be between -1 and 1.\n- $_ϵ_$ It’s called the residual and represents the difference between our prediction for period t and the correct value $(ϵ = y − ŷ)$.\n\nNow that we know what all the parts of the model represent, let’s try to interpret it. According to the equation, **values at a given period (_Xt_) are equal to some portion (_ϕ_1) of values in the last period (_Xt_ − 1), + some constant benchmark _C_ and unpredictable shocks** _ϵt_.\n\n## 3. What Is a Moving Average Model? (MA Model)\n\na model that considers **past residuals** . In other words, by knowing how far off our estimation yesterday was, compared to the actual value, we can tweak our model, so that it responds accordingly.\n\na simple Moving Average (MA) model looks like this:\n\n$$ r_t = c + θ_1 ϵ_{t-1} + ϵ_t $$\n\n- $_r$_ represents the values of “r” in the current period - t\n- _θ_ is a numeric coefficient for the value associated with the 1st lag. We prefer not to use _ϕ_ like in the Autoregressive model, to avoid confusion.\n- Then come _ϵ_ and _ϵ_ which represent the residuals for the current and the previous period, respectively.a residual is the same as an error term\n\n## 4. What Is an ARMA Model?\n\nThat’s why we need models that simultaneously use past data as a foundation for estimates, but can also quickly adjust to unpredictable shocks.\n\n**“ARMA”( Autoregressive Moving Average), which takes into account past values, as well as past errors when constructing future estimates**\n\n$_yt = c + ϕ1yt − 1 + θ1ϵt − 1 + ϵt_$\n\nHence, an ARMA (P, Q) model, takes the previous values up to P periods ago, but also takes the residuals of up to Q lags.\n\nThen, the equation for an ARMA (2,3) would look like this:\n\n$_yt = ϕ1yt − 1 + ϕ2yt − 2 + θ1ϵt − 1 + θ2ϵt − 2 + θ3ϵt − 3 + ϵt_$\n\n## 5. What Is an ARIMA Model?\n\nARIMA model has three orders – p, d, and q **(ARIMA(p,d,q))**. The “p” and “q” represent the [autoregressive (AR)](https://365datascience.com/tutorials/time-series-analysis-tutorials/autoregressive-model/) and [moving average (MA)](https://365datascience.com/tutorials/time-series-analysis-tutorials/moving-average-model/) lags just like with the ARMA models. The “d” order is the integration order.\n\n- ARIMA (p, 0, q) = ARMA (p, q)\n- ARIMA (0, 0, q) = MA(q)\n- ARIMA (p, 0, 0) = AR(p)\n\nThese integrated models account for the non-seasonal difference between periods to establish [stationarity](https://www.investopedia.com/articles/trading/07/stationary.asp).\n\nHence, even the AR components in the model should be price differences, (ΔP) rather than prices (P). In a sense, we are “integrating” “d”-many times to construct a new time-series and then fitting said series into an ARMA (p, q) model.\n\nARIMA (1,1,1): _ΔPt_ = _c_ + _ϕ_1_ΔPt_ − 1 + _θ_1_ϵt_ − 1 + _ϵt_\n\n- $ ΔP_{t-1} $is the difference between prices in period “t” and prices in the preceding period (ΔPt = Pt-1-Pt). Therefore, _ΔP_ is an entire time-series, which represents the disparity between prices of consecutive periods\n\n**Essentially, the entire ARIMA model is nothing more than an ARMA model for a newly generated time-series, which is stationary.**\n\n## 6. What Is an ARIMAX Model?\n\nHowever, a model can also take into account _more than just past prices or past residuals_.And these are the so-called “MAX” models, with the ARMAX being the non-integrated version and the ARIMAX - its integrated equivalent.\n\nThe names ARMAX and ARIMAX come as extensions of the [ARMA](https://365datascience.com/tutorials/time-series-analysis-tutorials/arma-model/) and [ARIMA](https://365datascience.com/tutorials/python-tutorials/arima/) respectively. The X added to the end stands for “exogenous”. In other words, it suggests adding a separate different outside variable to help measure our endogenous variable.\n\nARIMAX:\n\n$_ΔPt = c + βX + ϕ1ΔPt − 1 + θ1ϵt − 1 + ϵt_$\n\nARMAX:\n\n$_Pt = c + βX + ϕ1Pt − 1 + θ1ϵt − 1 + ϵt_$\n\n- Just like ϕ, β is a coefficient which will be estimated based on the model selection and the data\n- X is the exogenous variable and it can be any variable we’re interested in.Such outside factors are known as exogenous variables in our regression._We use their values to predict and explain the one we’re interested in_, which happens to be current prices in our case.\n\n## 7. What Is a SARIMAX Model?\n\n“S” representing the seasonal aspect. SARIMAX(Seasonal Autoregressive Integrated Moving Average Exogenous model)",
      "html": "<h1>Time-series-data</h1>\n<h2>1. How To Pre-Process Time Series Data</h2>\n<p><a href=\"https://365datascience.com/tutorials/time-series-analysis-tutorials/\">https://365datascience.com/tutorials/time-series-analysis-tutorials/</a></p>\n<h3>Summary</h3>\n<ul>\n<li><code>to_datetime</code>: string2date</li>\n<li><code>set_index</code>: date instead of index</li>\n<li><code>isna().sum()</code>: check NAN</li>\n<li><code>fillna</code>: fill no data</li>\n<li><code>asfreq</code>: set frequency</li>\n</ul>\n<h2>2. What Is an Autoregressive Model? (AR Model)</h2>\n<p>The Autoregressive Model, or AR model for short, relies only on past period values to predict current ones. It’s a linear model, where current period values are a sum of past outcomes multiplied by a numeric factor. We denote it as AR(p), where “p” is called the order of the model and represents the number of lagged values we want to include. For instance, if we take X as time-series variable, then an AR(1), also known as a simple autoregressive model, would look something like this:</p>\n<p>$$ X_t=C+ {\\phi}<em>1X</em>{t-1}+{\\epsilon}_t $$</p>\n<ul>\n<li>${\\phi}_1$ you can interpret it as the part of the previous value which remains in the future. It’s good to note that these coefficients should always be between -1 and 1.</li>\n<li>$<em>ϵ</em>$ It’s called the residual and represents the difference between our prediction for period t and the correct value $(ϵ = y − ŷ)$.</li>\n</ul>\n<p>Now that we know what all the parts of the model represent, let’s try to interpret it. According to the equation, <strong>values at a given period (<em>Xt</em>) are equal to some portion (_ϕ_1) of values in the last period (<em>Xt</em> − 1), + some constant benchmark <em>C</em> and unpredictable shocks</strong> <em>ϵt</em>.</p>\n<h2>3. What Is a Moving Average Model? (MA Model)</h2>\n<p>a model that considers <strong>past residuals</strong> . In other words, by knowing how far off our estimation yesterday was, compared to the actual value, we can tweak our model, so that it responds accordingly.</p>\n<p>a simple Moving Average (MA) model looks like this:</p>\n<p>$$ r_t = c + θ_1 ϵ_{t-1} + ϵ_t $$</p>\n<ul>\n<li>$<em>r$</em> represents the values of “r” in the current period - t</li>\n<li><em>θ</em> is a numeric coefficient for the value associated with the 1st lag. We prefer not to use <em>ϕ</em> like in the Autoregressive model, to avoid confusion.</li>\n<li>Then come <em>ϵ</em> and <em>ϵ</em> which represent the residuals for the current and the previous period, respectively.a residual is the same as an error term</li>\n</ul>\n<h2>4. What Is an ARMA Model?</h2>\n<p>That’s why we need models that simultaneously use past data as a foundation for estimates, but can also quickly adjust to unpredictable shocks.</p>\n<p><strong>“ARMA”( Autoregressive Moving Average), which takes into account past values, as well as past errors when constructing future estimates</strong></p>\n<p>$<em>yt = c + ϕ1yt − 1 + θ1ϵt − 1 + ϵt</em>$</p>\n<p>Hence, an ARMA (P, Q) model, takes the previous values up to P periods ago, but also takes the residuals of up to Q lags.</p>\n<p>Then, the equation for an ARMA (2,3) would look like this:</p>\n<p>$<em>yt = ϕ1yt − 1 + ϕ2yt − 2 + θ1ϵt − 1 + θ2ϵt − 2 + θ3ϵt − 3 + ϵt</em>$</p>\n<h2>5. What Is an ARIMA Model?</h2>\n<p>ARIMA model has three orders – p, d, and q <strong>(ARIMA(p,d,q))</strong>. The “p” and “q” represent the <a href=\"https://365datascience.com/tutorials/time-series-analysis-tutorials/autoregressive-model/\">autoregressive (AR)</a> and <a href=\"https://365datascience.com/tutorials/time-series-analysis-tutorials/moving-average-model/\">moving average (MA)</a> lags just like with the ARMA models. The “d” order is the integration order.</p>\n<ul>\n<li>ARIMA (p, 0, q) = ARMA (p, q)</li>\n<li>ARIMA (0, 0, q) = MA(q)</li>\n<li>ARIMA (p, 0, 0) = AR(p)</li>\n</ul>\n<p>These integrated models account for the non-seasonal difference between periods to establish <a href=\"https://www.investopedia.com/articles/trading/07/stationary.asp\">stationarity</a>.</p>\n<p>Hence, even the AR components in the model should be price differences, (ΔP) rather than prices (P). In a sense, we are “integrating” “d”-many times to construct a new time-series and then fitting said series into an ARMA (p, q) model.</p>\n<p>ARIMA (1,1,1): <em>ΔPt</em> = <em>c</em> + <em>ϕ_1_ΔPt</em> − 1 + <em>θ_1_ϵt</em> − 1 + <em>ϵt</em></p>\n<ul>\n<li>$ ΔP_{t-1} $is the difference between prices in period “t” and prices in the preceding period (ΔPt = Pt-1-Pt). Therefore, <em>ΔP</em> is an entire time-series, which represents the disparity between prices of consecutive periods</li>\n</ul>\n<p><strong>Essentially, the entire ARIMA model is nothing more than an ARMA model for a newly generated time-series, which is stationary.</strong></p>\n<h2>6. What Is an ARIMAX Model?</h2>\n<p>However, a model can also take into account <em>more than just past prices or past residuals</em>.And these are the so-called “MAX” models, with the ARMAX being the non-integrated version and the ARIMAX - its integrated equivalent.</p>\n<p>The names ARMAX and ARIMAX come as extensions of the <a href=\"https://365datascience.com/tutorials/time-series-analysis-tutorials/arma-model/\">ARMA</a> and <a href=\"https://365datascience.com/tutorials/python-tutorials/arima/\">ARIMA</a> respectively. The X added to the end stands for “exogenous”. In other words, it suggests adding a separate different outside variable to help measure our endogenous variable.</p>\n<p>ARIMAX:</p>\n<p>$<em>ΔPt = c + βX + ϕ1ΔPt − 1 + θ1ϵt − 1 + ϵt</em>$</p>\n<p>ARMAX:</p>\n<p>$<em>Pt = c + βX + ϕ1Pt − 1 + θ1ϵt − 1 + ϵt</em>$</p>\n<ul>\n<li>Just like ϕ, β is a coefficient which will be estimated based on the model selection and the data</li>\n<li>X is the exogenous variable and it can be any variable we’re interested in.Such outside factors are known as exogenous variables in our regression.<em>We use their values to predict and explain the one we’re interested in</em>, which happens to be current prices in our case.</li>\n</ul>\n<h2>7. What Is a SARIMAX Model?</h2>\n<p>“S” representing the seasonal aspect. SARIMAX(Seasonal Autoregressive Integrated Moving Average Exogenous model)</p>"
    },
    "_id": "post/2023-11-28-Time-series-data.md",
    "_raw": {
      "sourceFilePath": "post/2023-11-28-Time-series-data.md",
      "sourceFileName": "2023-11-28-Time-series-data.md",
      "sourceFileDir": "post",
      "contentType": "markdown",
      "flattenedPath": "post/2023-11-28-Time-series-data"
    },
    "type": "Post",
    "id": ""
  },
  {
    "title": "Diffusion Learning",
    "url": "/2023-12-01-Diffusion Learning",
    "description": null,
    "date": "2023-12-01T00:00:00.000Z",
    "body": {
      "raw": "\n\n![Untitled.png](https://raw.githubusercontent.com/heavenmei/heavenmei.github.io/master/images/202312121119465.png)\n## 评价指标\n\n### Frechet Inception Distance（FID）\n\n评价一张图片的好坏，首先需要一个训练好的分类器，然后比较生成图片与真实图片representation之间的距离，距离越小越好，这需要大量图片来测量。\n\n![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/ab32932e-bd14-4d15-8f07-f8a7c6cbab59/Untitled.png)\n\n### ****Contrastive Language-Image Pre-Training（CLIP）****\n\n使用CLIP模型根据对应的文字描述来判断生成图像的质量。400million text-image pairs\n\n![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/c2e08dfd-038a-4e6b-b309-b5468c97cb45/Untitled.png)\n\n## Diffusion Model原理 [DDPM](https://arxiv.org/abs/2006.11239)\n\n### 去噪声（生成）\n\n不同时序使用的是**同一个denoise模型**，但是因为输入图片的状态有很大的不同，所以需要把step本身也输入到denoise模型，让它知道当前图片的去噪状况。\n\n![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/e2165ea8-9a3e-4a71-85cf-03fcb86bd597/Untitled.png)\n\nDenoise模块中存在一个Predicter，它用来预测输入图片的噪声，再用要被denoise的图片减去噪声就可以得到denoise之后的图片了。\n\n![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/5b5b5fee-eef5-4232-9bd6-84bbd4c29ccb/Untitled.png)\n\n![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/04f30b69-2ba4-4b55-b86b-3bae8be58906/Untitled.png)\n\n### 加噪声（训练）\n\n那么这个Noise Predicter如何训练呢？在训练时，我们首先需要根据原始无噪声的图片认为生成Predicter的噪声Ground truth。\n\n![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/09513c5b-d848-46f1-8b50-78724bf6a1d7/Untitled.png)\n\n在forward process（前向过程）中已经存储了GT，得到了标签。\n\n![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/6b58c56a-6008-401a-9b0d-e27947f04d4d/Untitled.png)\n\n![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/d497cf60-bce6-4b2f-9bd1-2e35e4801f27/Untitled.png)\n\n![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/8b212294-180e-43bf-9b9f-cff8b4482f13/Untitled.png)\n\n## Text2Image框架\n\n![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/4bc084c0-52d2-451f-a2c2-f696f7d22757/Untitled.png)\n\n从这个framework中可以看出，文字是没有办法直接输入到模型中的，首先需要一个encoder（GPT,BERT）将文本编码成token，再和噪声一起输入到生成模型（也就是diffusion模型），得到的中间产物最后通过一个decoder生成最终的图像。**其中decoder的训练数据可以不需要标签。**\n\n### ****Stable Diffusion、DALL-E、Imagen****各自框架\n\n> [Stable Diffusion](https://www.notion.so/High-Resolution-Image-Synthesis-with-Latent-Diffusion-Models-66e17659d5e145ea93ed2eaef546d1aa?pvs=21)\n> \n> ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/b4000e36-993d-4d92-9eca-e5ae94c34f3f/Untitled.png)\n\n> DALLE-E\n> \n> ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/3a0a2626-17e4-47f5-97eb-f731ec71e0ce/Untitled.png)\n\n> Imagen\n> \n> ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/d8a3db67-2e42-4fae-a1b3-57dcb3a66bbd/Untitled.png)\n\n### Decoder\n\nDecoder的输入有两种情况，一种是denoise图片的压缩版本（imagen），一种是latent representation（stable diffusion）。对于前者非常简单，只需要拿很多downsample的图片来训练就可以了。对于后者需要训练一个auto encoder，把decoder拿出来。**decoder的训练数据可以不需要标签**\n\n![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/ea9fd821-b38b-4e77-89a2-25bc1a224140/Untitled.png)\n\n![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/924e059b-04e6-43ea-a5cd-ae272dc3bf8b/Untitled.png)\n\n### Generation Model\n\n对于framework中的生成模型，noise加在中间产物（latent representation）上而不是原始图像上。",
      "html": "<p><img src=\"https://raw.githubusercontent.com/heavenmei/heavenmei.github.io/master/images/202312121119465.png\" alt=\"Untitled.png\"></p>\n<h2>评价指标</h2>\n<h3>Frechet Inception Distance（FID）</h3>\n<p>评价一张图片的好坏，首先需要一个训练好的分类器，然后比较生成图片与真实图片representation之间的距离，距离越小越好，这需要大量图片来测量。</p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/ab32932e-bd14-4d15-8f07-f8a7c6cbab59/Untitled.png\" alt=\"Untitled\"></p>\n<h3><strong><strong>Contrastive Language-Image Pre-Training（CLIP）</strong></strong></h3>\n<p>使用CLIP模型根据对应的文字描述来判断生成图像的质量。400million text-image pairs</p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/c2e08dfd-038a-4e6b-b309-b5468c97cb45/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Diffusion Model原理 <a href=\"https://arxiv.org/abs/2006.11239\">DDPM</a></h2>\n<h3>去噪声（生成）</h3>\n<p>不同时序使用的是<strong>同一个denoise模型</strong>，但是因为输入图片的状态有很大的不同，所以需要把step本身也输入到denoise模型，让它知道当前图片的去噪状况。</p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/e2165ea8-9a3e-4a71-85cf-03fcb86bd597/Untitled.png\" alt=\"Untitled\"></p>\n<p>Denoise模块中存在一个Predicter，它用来预测输入图片的噪声，再用要被denoise的图片减去噪声就可以得到denoise之后的图片了。</p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/5b5b5fee-eef5-4232-9bd6-84bbd4c29ccb/Untitled.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/04f30b69-2ba4-4b55-b86b-3bae8be58906/Untitled.png\" alt=\"Untitled\"></p>\n<h3>加噪声（训练）</h3>\n<p>那么这个Noise Predicter如何训练呢？在训练时，我们首先需要根据原始无噪声的图片认为生成Predicter的噪声Ground truth。</p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/09513c5b-d848-46f1-8b50-78724bf6a1d7/Untitled.png\" alt=\"Untitled\"></p>\n<p>在forward process（前向过程）中已经存储了GT，得到了标签。</p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/6b58c56a-6008-401a-9b0d-e27947f04d4d/Untitled.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/d497cf60-bce6-4b2f-9bd1-2e35e4801f27/Untitled.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/8b212294-180e-43bf-9b9f-cff8b4482f13/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Text2Image框架</h2>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/4bc084c0-52d2-451f-a2c2-f696f7d22757/Untitled.png\" alt=\"Untitled\"></p>\n<p>从这个framework中可以看出，文字是没有办法直接输入到模型中的，首先需要一个encoder（GPT,BERT）将文本编码成token，再和噪声一起输入到生成模型（也就是diffusion模型），得到的中间产物最后通过一个decoder生成最终的图像。<strong>其中decoder的训练数据可以不需要标签。</strong></p>\n<h3><strong><strong>Stable Diffusion、DALL-E、Imagen</strong></strong>各自框架</h3>\n<blockquote>\n<p><a href=\"https://www.notion.so/High-Resolution-Image-Synthesis-with-Latent-Diffusion-Models-66e17659d5e145ea93ed2eaef546d1aa?pvs=21\">Stable Diffusion</a></p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/b4000e36-993d-4d92-9eca-e5ae94c34f3f/Untitled.png\" alt=\"Untitled\"></p>\n</blockquote>\n<blockquote>\n<p>DALLE-E</p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/3a0a2626-17e4-47f5-97eb-f731ec71e0ce/Untitled.png\" alt=\"Untitled\"></p>\n</blockquote>\n<blockquote>\n<p>Imagen</p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/d8a3db67-2e42-4fae-a1b3-57dcb3a66bbd/Untitled.png\" alt=\"Untitled\"></p>\n</blockquote>\n<h3>Decoder</h3>\n<p>Decoder的输入有两种情况，一种是denoise图片的压缩版本（imagen），一种是latent representation（stable diffusion）。对于前者非常简单，只需要拿很多downsample的图片来训练就可以了。对于后者需要训练一个auto encoder，把decoder拿出来。<strong>decoder的训练数据可以不需要标签</strong></p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/ea9fd821-b38b-4e77-89a2-25bc1a224140/Untitled.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/568ff324-820e-4458-94c0-e72a5b6a8e65/924e059b-04e6-43ea-a5cd-ae272dc3bf8b/Untitled.png\" alt=\"Untitled\"></p>\n<h3>Generation Model</h3>\n<p>对于framework中的生成模型，noise加在中间产物（latent representation）上而不是原始图像上。</p>"
    },
    "_id": "post/2023-12-01-Diffusion Learning.md",
    "_raw": {
      "sourceFilePath": "post/2023-12-01-Diffusion Learning.md",
      "sourceFileName": "2023-12-01-Diffusion Learning.md",
      "sourceFileDir": "post",
      "contentType": "markdown",
      "flattenedPath": "post/2023-12-01-Diffusion Learning"
    },
    "type": "Post",
    "id": ""
  },
  {
    "title": "前端自动化CI/CD：Github Action部署项目到服务器",
    "url": "/2023-12-11-CICD",
    "date": "2023-12-11T00:00:00.000Z",
    "body": {
      "raw": "> **What‘s Github Action？**  \n> [GitHub Actions](https://github.com/features/actions) 是 GitHub 的持续集成服务(CI/CD)。\n> 想要了解的朋友移步 [GitHub Actions 入门教程](https://link.juejin.cn/?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2019%2F09%2Fgetting-started-with-github-actions.html \"https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html\")\n\n\n### 编写workflow\n创建`.github/workflows` 文件夹，创建`demo.yml`文件\n\n主要流程：\n1. 拉取main分支的最新代码\n2. 设置node版本号\n3. 缓存依赖\n4. 安装依赖\n5. 打包\n6. 上传资源到指定路径\n\n```yaml\nname: Node CI\n\n# 触发workflow的条件\non:\n\tpush:\n\t\tbranches: [ \"main\" ]\n\tpull_request:\n\t\tbranches: [ \"main\" ]\n\n# jobs表示执行的一项或多项任务\njobs:\n\t# 任务的job_id，具体名称自定义，这里build代表打包\n\tbuild:\n\t\truns-on: ubuntu-latest\n\t\tstrategy:\n\t\t\tmatrix:\n\t\t\t\tnode-version: [18.18.2]\n\n\t\tsteps:\n\t\t\t  # 拉取main分支最新代码\n\t\t\t  uses: actions/checkout@main\n\t\t\t  \n\t\t\t  # 确定node版本\n\t\t\t- name: Use Node.js ${{ matrix.node-version }}\n\t\t\t  uses: actions/setup-node@v3\n\t\t\t  with:\n\t\t\t\tnode-version: ${{ matrix.node-version }}\n\t\t\n\t\t\t # 缓存依赖\n\t\t\t- name: Cache nodemodules\n\t\t\t  uses: actions/cache@v1\n\t\t\t  env:\n\t\t\t\tcache-name: cache-node-modules\n\t\t\t  with:\n\t\t\t    # 需要缓存的文件的路径\n\t\t\t\tpath: ./node_modules \n\t\t\t\t# 对缓存的文件指定的唯一标识\n\t\t\t\tkey: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('./package.json') }} \n\t\t\t\t# 用于没有再找目标key的缓存的backup选项\n\t\t\t\trestore-keys: |\n\t\t\t\t\t${{ runner.os }}-build-${{ env.cache-name }}-\n\t\t\t\t\t${{ runner.os }}-build-\n\t\t\t\t\t${{ runner.os }}-\n\t\t\n\t\t\t# 装依赖\n\t\t\t- name: Install\n\t\t\t  run: |\n\t\t\t\tnpm install -g yarn@1.22.19\n\t\t\t\tyarn install\n```\n\n\n### 打包\n本地开发时会把所需要的环境编写在.env 文件内，并且不会上传到github上以保证仓库隐私性。因此，在打包时若有相关生产环境变量，可以直接定义在 secret中\n\n![Pasted image 20231211150807.png](https://raw.githubusercontent.com/heavenmei/heavenmei.github.io/master/images/202312111641617.png)\n\n\n在脚本中引用\n```yaml\n\nenv:\n\tVITE_SERVER_NAME: ${{ secrets.VITE_SERVER_NAME }} # 服务器域名\n\tcache-name: note\n\njobs:\n\tbuild:\n\t\tsteps:\n\t\t\t...\n\t\t\t# 打包\n\t\t\t- name: Build\n\t\t\trun: |\n\t\t\t\techo \"VITE_SERVER_NAME = ${{ env.VITE_SERVER_NAME }}\" > .env\n\t\t\t\tyarn build\n\n```\n\n### 部署\n部署思想：首先利用ssh 将打包好的资源上传到服务器上，服务器上利用pm2 管理node进程，nginx反向代理端口，脚本重启pm2该项目进程。\n\n1. 在服务器配置nginx指向前端运行的端口\n```shell\nserver {\n\tlisten 8889;  # 对外接口\n\tserver_name api.msg.com;\n\t\n\tlocation / {\n\t\tproxy_pass http://localhost:3008; # 服务器本地运行前端端口\n\t\tadd_header backendIP $upstream_addr;\n\t\tadd_header backendCode $upstream_status;\n\t}\n}\n```\n2. 服务器创建秘钥对\n将本机与服务器创建密钥对，并把本地公钥加入`.ssh/authorized_keys`中，同时保存到github secrets。\n```yaml\n\nenv:\n\tSERVER_PRIVATE_KEY: ${{ secrets.SERVER_PRIVATE_KEY }} # 服务器私钥\n\tSERVER_HOST: ${{ secrets.SERVER_HOST }} # 服务器IP地址\n\tUSER_NAME: ${{ secrets.USER_NAME }} # 服务器用户名\n\njobs:\n\tbuild:\n\t\tsteps:\n\t\t\t...\n\t\t\t# 上传打包资源\n\t\t\t- name: Deploy\n\t\t\tuses: easingthemes/ssh-deploy@v3\n\t\t\tenv:\n\t\t\t\tSSH_PRIVATE_KEY: ${{ env.SERVER_PRIVATE_KEY }}\n\t\t\t\tARGS: '-avz --delete'\n\t\t\t\tSOURCE: '.output/' # \n\t\t\t\t\n\t\t\t\tREMOTE_HOST: ${{ env.SERVER_HOST }}\n\t\t\t\tREMOTE_USER: ${{ env.USER_NAME }}\n\t\t\t\tTARGET: /root/i-lion-front/.output # 服务器目标路径\n```\n\n3. 重新部署脚本\n首先在服务器中安装[pm2](https://pm2.keymetrics.io/)并启动运行该项目，服务器中创建重启脚本`run_node.sh`\n```shell\npm2 reload xxx/ecosystem.config.cjs\n```\naction 执行该脚本\n```yaml\n# 重新部署\n\n- name: Reload pm2\n  uses: appleboy/ssh-action@master\n  with:\n\thost: ${{ env.SERVER_HOST }}\n\tusername: ${{ env.USER_NAME }}\n\tkey: ${{ env.SERVER_PRIVATE_KEY }}\n\tscript: |\n\t\t# 在服务器中执行的命令\n\t\tzsh xxxrun_node.sh\n```\n\n\n### 执行\n GitHub Actions 绑定`.github/workflows/demo.yml` ，执行结果如下：\n ![](https://raw.githubusercontent.com/heavenmei/heavenmei.github.io/master/images/202312111642891.png)\n### 完整代码\n\n```yaml\nname: Node CI\n\n# 触发workflow的条件\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    branches: [ \"main\" ]\n\nenv:\n    SERVER_PRIVATE_KEY: ${{ secrets.SERVER_PRIVATE_KEY }} # 服务器私钥\n    SERVER_HOST: ${{ secrets.SERVER_HOST }} # 服务器IP地址\n    USER_NAME: ${{ secrets.USER_NAME }} # 服务器用户名\n    VITE_SERVER_NAME: ${{ secrets.VITE_SERVER_NAME }} \n    cache-name: note\n    \njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [18.18.2]\n        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/\n\n    steps:\n    - uses: actions/checkout@main\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v3\n      with:\n        node-version: ${{ matrix.node-version }}\n     #缓存依赖\n    - name: Cache nodemodules\n      uses: actions/cache@v1\n      env:\n          cache-name: cache-node-modules\n      with:\n          # 需要缓存的文件的路径\n          path: ./node_modules \n          # 对缓存的文件指定的唯一标识\n          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('./package.json') }} \n          # 用于没有再找目标key的缓存的backup选项\n          restore-keys: |\n              ${{ runner.os }}-build-${{ env.cache-name }}-\n              ${{ runner.os }}-build-\n              ${{ runner.os }}-\n    # 装依赖\n    - name: Install\n      run: |\n          npm install -g yarn@1.22.19\n          yarn install\n    # 打包\n    - name: Build\n      run: |\n          echo \"VITE_SERVER_NAME = ${{ env.VITE_SERVER_NAME }}\" > .env\n          yarn build\n    # 上传打包资源\n    - name: Deploy\n      uses: easingthemes/ssh-deploy@v3\n      env:\n          SSH_PRIVATE_KEY: ${{ env.SERVER_PRIVATE_KEY }}\n          ARGS: '-avz --delete'\n          SOURCE: '.output/'\n          REMOTE_HOST: ${{ env.SERVER_HOST }}\n          REMOTE_USER: ${{ env.USER_NAME }}\n          TARGET: /root/i-lion-front/.output # 服务器目标路径\n    # 重新部署\n    - name: Reload pm2\n      uses: appleboy/ssh-action@master\n      with:\n        host: ${{ env.SERVER_HOST }}\n        username: ${{ env.USER_NAME }}\n        key: ${{ env.SERVER_PRIVATE_KEY }}\n        script: |\n          source /www/server/nvm/nvm.sh\n          nvm use 18.18.2\n          zsh /root/i-lion-front/run_node.sh\n\n```",
      "html": "<blockquote>\n<p><strong>What‘s Github Action？</strong><br>\n<a href=\"https://github.com/features/actions\">GitHub Actions</a> 是 GitHub 的持续集成服务(CI/CD)。\n想要了解的朋友移步 <a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2019%2F09%2Fgetting-started-with-github-actions.html\" title=\"https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html\">GitHub Actions 入门教程</a></p>\n</blockquote>\n<h3>编写workflow</h3>\n<p>创建<code>.github/workflows</code> 文件夹，创建<code>demo.yml</code>文件</p>\n<p>主要流程：</p>\n<ol>\n<li>拉取main分支的最新代码</li>\n<li>设置node版本号</li>\n<li>缓存依赖</li>\n<li>安装依赖</li>\n<li>打包</li>\n<li>上传资源到指定路径</li>\n</ol>\n<pre><code class=\"language-yaml\">name: Node CI\n\n# 触发workflow的条件\non:\n\tpush:\n\t\tbranches: [ \"main\" ]\n\tpull_request:\n\t\tbranches: [ \"main\" ]\n\n# jobs表示执行的一项或多项任务\njobs:\n\t# 任务的job_id，具体名称自定义，这里build代表打包\n\tbuild:\n\t\truns-on: ubuntu-latest\n\t\tstrategy:\n\t\t\tmatrix:\n\t\t\t\tnode-version: [18.18.2]\n\n\t\tsteps:\n\t\t\t  # 拉取main分支最新代码\n\t\t\t  uses: actions/checkout@main\n\t\t\t  \n\t\t\t  # 确定node版本\n\t\t\t- name: Use Node.js ${{ matrix.node-version }}\n\t\t\t  uses: actions/setup-node@v3\n\t\t\t  with:\n\t\t\t\tnode-version: ${{ matrix.node-version }}\n\t\t\n\t\t\t # 缓存依赖\n\t\t\t- name: Cache nodemodules\n\t\t\t  uses: actions/cache@v1\n\t\t\t  env:\n\t\t\t\tcache-name: cache-node-modules\n\t\t\t  with:\n\t\t\t    # 需要缓存的文件的路径\n\t\t\t\tpath: ./node_modules \n\t\t\t\t# 对缓存的文件指定的唯一标识\n\t\t\t\tkey: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('./package.json') }} \n\t\t\t\t# 用于没有再找目标key的缓存的backup选项\n\t\t\t\trestore-keys: |\n\t\t\t\t\t${{ runner.os }}-build-${{ env.cache-name }}-\n\t\t\t\t\t${{ runner.os }}-build-\n\t\t\t\t\t${{ runner.os }}-\n\t\t\n\t\t\t# 装依赖\n\t\t\t- name: Install\n\t\t\t  run: |\n\t\t\t\tnpm install -g yarn@1.22.19\n\t\t\t\tyarn install\n</code></pre>\n<h3>打包</h3>\n<p>本地开发时会把所需要的环境编写在.env 文件内，并且不会上传到github上以保证仓库隐私性。因此，在打包时若有相关生产环境变量，可以直接定义在 secret中</p>\n<p><img src=\"https://raw.githubusercontent.com/heavenmei/heavenmei.github.io/master/images/202312111641617.png\" alt=\"Pasted image 20231211150807.png\"></p>\n<p>在脚本中引用</p>\n<pre><code class=\"language-yaml\">\nenv:\n\tVITE_SERVER_NAME: ${{ secrets.VITE_SERVER_NAME }} # 服务器域名\n\tcache-name: note\n\njobs:\n\tbuild:\n\t\tsteps:\n\t\t\t...\n\t\t\t# 打包\n\t\t\t- name: Build\n\t\t\trun: |\n\t\t\t\techo \"VITE_SERVER_NAME = ${{ env.VITE_SERVER_NAME }}\" > .env\n\t\t\t\tyarn build\n\n</code></pre>\n<h3>部署</h3>\n<p>部署思想：首先利用ssh 将打包好的资源上传到服务器上，服务器上利用pm2 管理node进程，nginx反向代理端口，脚本重启pm2该项目进程。</p>\n<ol>\n<li>在服务器配置nginx指向前端运行的端口</li>\n</ol>\n<pre><code class=\"language-shell\">server {\n\tlisten 8889;  # 对外接口\n\tserver_name api.msg.com;\n\t\n\tlocation / {\n\t\tproxy_pass http://localhost:3008; # 服务器本地运行前端端口\n\t\tadd_header backendIP $upstream_addr;\n\t\tadd_header backendCode $upstream_status;\n\t}\n}\n</code></pre>\n<ol start=\"2\">\n<li>服务器创建秘钥对\n将本机与服务器创建密钥对，并把本地公钥加入<code>.ssh/authorized_keys</code>中，同时保存到github secrets。</li>\n</ol>\n<pre><code class=\"language-yaml\">\nenv:\n\tSERVER_PRIVATE_KEY: ${{ secrets.SERVER_PRIVATE_KEY }} # 服务器私钥\n\tSERVER_HOST: ${{ secrets.SERVER_HOST }} # 服务器IP地址\n\tUSER_NAME: ${{ secrets.USER_NAME }} # 服务器用户名\n\njobs:\n\tbuild:\n\t\tsteps:\n\t\t\t...\n\t\t\t# 上传打包资源\n\t\t\t- name: Deploy\n\t\t\tuses: easingthemes/ssh-deploy@v3\n\t\t\tenv:\n\t\t\t\tSSH_PRIVATE_KEY: ${{ env.SERVER_PRIVATE_KEY }}\n\t\t\t\tARGS: '-avz --delete'\n\t\t\t\tSOURCE: '.output/' # \n\t\t\t\t\n\t\t\t\tREMOTE_HOST: ${{ env.SERVER_HOST }}\n\t\t\t\tREMOTE_USER: ${{ env.USER_NAME }}\n\t\t\t\tTARGET: /root/i-lion-front/.output # 服务器目标路径\n</code></pre>\n<ol start=\"3\">\n<li>重新部署脚本\n首先在服务器中安装<a href=\"https://pm2.keymetrics.io/\">pm2</a>并启动运行该项目，服务器中创建重启脚本<code>run_node.sh</code></li>\n</ol>\n<pre><code class=\"language-shell\">pm2 reload xxx/ecosystem.config.cjs\n</code></pre>\n<p>action 执行该脚本</p>\n<pre><code class=\"language-yaml\"># 重新部署\n\n- name: Reload pm2\n  uses: appleboy/ssh-action@master\n  with:\n\thost: ${{ env.SERVER_HOST }}\n\tusername: ${{ env.USER_NAME }}\n\tkey: ${{ env.SERVER_PRIVATE_KEY }}\n\tscript: |\n\t\t# 在服务器中执行的命令\n\t\tzsh xxxrun_node.sh\n</code></pre>\n<h3>执行</h3>\n<p>GitHub Actions 绑定<code>.github/workflows/demo.yml</code> ，执行结果如下：\n<img src=\"https://raw.githubusercontent.com/heavenmei/heavenmei.github.io/master/images/202312111642891.png\" alt=\"\"></p>\n<h3>完整代码</h3>\n<pre><code class=\"language-yaml\">name: Node CI\n\n# 触发workflow的条件\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    branches: [ \"main\" ]\n\nenv:\n    SERVER_PRIVATE_KEY: ${{ secrets.SERVER_PRIVATE_KEY }} # 服务器私钥\n    SERVER_HOST: ${{ secrets.SERVER_HOST }} # 服务器IP地址\n    USER_NAME: ${{ secrets.USER_NAME }} # 服务器用户名\n    VITE_SERVER_NAME: ${{ secrets.VITE_SERVER_NAME }} \n    cache-name: note\n    \njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [18.18.2]\n        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/\n\n    steps:\n    - uses: actions/checkout@main\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v3\n      with:\n        node-version: ${{ matrix.node-version }}\n     #缓存依赖\n    - name: Cache nodemodules\n      uses: actions/cache@v1\n      env:\n          cache-name: cache-node-modules\n      with:\n          # 需要缓存的文件的路径\n          path: ./node_modules \n          # 对缓存的文件指定的唯一标识\n          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('./package.json') }} \n          # 用于没有再找目标key的缓存的backup选项\n          restore-keys: |\n              ${{ runner.os }}-build-${{ env.cache-name }}-\n              ${{ runner.os }}-build-\n              ${{ runner.os }}-\n    # 装依赖\n    - name: Install\n      run: |\n          npm install -g yarn@1.22.19\n          yarn install\n    # 打包\n    - name: Build\n      run: |\n          echo \"VITE_SERVER_NAME = ${{ env.VITE_SERVER_NAME }}\" > .env\n          yarn build\n    # 上传打包资源\n    - name: Deploy\n      uses: easingthemes/ssh-deploy@v3\n      env:\n          SSH_PRIVATE_KEY: ${{ env.SERVER_PRIVATE_KEY }}\n          ARGS: '-avz --delete'\n          SOURCE: '.output/'\n          REMOTE_HOST: ${{ env.SERVER_HOST }}\n          REMOTE_USER: ${{ env.USER_NAME }}\n          TARGET: /root/i-lion-front/.output # 服务器目标路径\n    # 重新部署\n    - name: Reload pm2\n      uses: appleboy/ssh-action@master\n      with:\n        host: ${{ env.SERVER_HOST }}\n        username: ${{ env.USER_NAME }}\n        key: ${{ env.SERVER_PRIVATE_KEY }}\n        script: |\n          source /www/server/nvm/nvm.sh\n          nvm use 18.18.2\n          zsh /root/i-lion-front/run_node.sh\n\n</code></pre>"
    },
    "_id": "post/2023-12-11-Front CICD with Github Actions.md",
    "_raw": {
      "sourceFilePath": "post/2023-12-11-Front CICD with Github Actions.md",
      "sourceFileName": "2023-12-11-Front CICD with Github Actions.md",
      "sourceFileDir": "post",
      "contentType": "markdown",
      "flattenedPath": "post/2023-12-11-Front CICD with Github Actions"
    },
    "type": "Post",
    "id": ""
  },
  {
    "title": "ubuntu",
    "url": "/2023-12-23-ubuntu-docker",
    "date": "2023-12-23T00:00:00.000Z",
    "body": {
      "raw": "> 在服务器中安装docker， 并创建pytorch运行环境，实现ssh远程端口登录\n\ndocker安装详见一键安装脚本\nhttps://gitee.com/heavenmei/one-step-install\n\n### 创建容器\n\n镜像仓库： https://hub.docker.com/r/pytorch/pytorch/tags\n```shell\ndocker pull pytorch/pytorch:2.1.2-cuda11.8-cudnn8-devel\n```\n运行容器，这一步尤其重要，要指定好一些参数\n```shell\ndocker run -itd -p 8080:8080 -gpus all --name \"hhw_pyt2\"\n```\n\n\n### 环境配置\n```shell\napt-get update\napt-get install -y curl git openssh-server vim\n```\n\n\n\n### 配置ssh 连接docker 容器\n```shell\n# 1. 安装\napt-get install -y openssh-server \n# 2. 设置登录密码 \npasswd \n\n# 3. 修改配置文件 \nvim /etc/ssh/sshd_config \n开启root登录 PermitRootLogin yes \n开启密码认证 PasswordAuthentication yes\n\n# 4.设置开机自启 systemctl enable ssh 只在宿主机上有效\necho \"service ssh start\" >> ~/.bashrc\n\n# 5.重启\nservice ssh restart\n```\n\n设置完成，即可通过ssh远程访问：（默认root） `ssh -p PORT root@IP`\n\n**SSH连接Docker容器时环境变量丢失** \n在容器中安装openssh-server后，启动ssh服务，然后从外部连接ssh进入docker后，会发现所有的容器环境变量都不见了，只剩下一些ssh必要的环境变量 可以把容器主进程的环境变量拿出来：在ssh的shell中执行。\n```shell\nexport $(cat /proc/1/environ |tr '\\0' '\\n' | xargs)\n# 加到.bashrc 登录默认进入改进程\necho \"export \\$(cat /proc/1/environ |tr '\\0' '\\n' | xargs)\" >> ~/.bashrc\n```",
      "html": "<blockquote>\n<p>在服务器中安装docker， 并创建pytorch运行环境，实现ssh远程端口登录</p>\n</blockquote>\n<p>docker安装详见一键安装脚本\nhttps://gitee.com/heavenmei/one-step-install</p>\n<h3>创建容器</h3>\n<p>镜像仓库： https://hub.docker.com/r/pytorch/pytorch/tags</p>\n<pre><code class=\"language-shell\">docker pull pytorch/pytorch:2.1.2-cuda11.8-cudnn8-devel\n</code></pre>\n<p>运行容器，这一步尤其重要，要指定好一些参数</p>\n<pre><code class=\"language-shell\">docker run -itd -p 8080:8080 -gpus all --name \"hhw_pyt2\"\n</code></pre>\n<h3>环境配置</h3>\n<pre><code class=\"language-shell\">apt-get update\napt-get install -y curl git openssh-server vim\n</code></pre>\n<h3>配置ssh 连接docker 容器</h3>\n<pre><code class=\"language-shell\"># 1. 安装\napt-get install -y openssh-server \n# 2. 设置登录密码 \npasswd \n\n# 3. 修改配置文件 \nvim /etc/ssh/sshd_config \n开启root登录 PermitRootLogin yes \n开启密码认证 PasswordAuthentication yes\n\n# 4.设置开机自启 systemctl enable ssh 只在宿主机上有效\necho \"service ssh start\" >> ~/.bashrc\n\n# 5.重启\nservice ssh restart\n</code></pre>\n<p>设置完成，即可通过ssh远程访问：（默认root） <code>ssh -p PORT root@IP</code></p>\n<p><strong>SSH连接Docker容器时环境变量丢失</strong>\n在容器中安装openssh-server后，启动ssh服务，然后从外部连接ssh进入docker后，会发现所有的容器环境变量都不见了，只剩下一些ssh必要的环境变量 可以把容器主进程的环境变量拿出来：在ssh的shell中执行。</p>\n<pre><code class=\"language-shell\">export $(cat /proc/1/environ |tr '\\0' '\\n' | xargs)\n# 加到.bashrc 登录默认进入改进程\necho \"export \\$(cat /proc/1/environ |tr '\\0' '\\n' | xargs)\" >> ~/.bashrc\n</code></pre>"
    },
    "_id": "post/2023-12-23-ubuntu-docker-pytorch-ssh.md",
    "_raw": {
      "sourceFilePath": "post/2023-12-23-ubuntu-docker-pytorch-ssh.md",
      "sourceFileName": "2023-12-23-ubuntu-docker-pytorch-ssh.md",
      "sourceFileDir": "post",
      "contentType": "markdown",
      "flattenedPath": "post/2023-12-23-ubuntu-docker-pytorch-ssh"
    },
    "type": "Post",
    "id": ""
  },
  {
    "title": "tiptap接入富文本编辑器",
    "url": "/2023-12-27-tiptap",
    "date": "2023-12-27T00:00:00.000Z",
    "body": {
      "raw": "",
      "html": ""
    },
    "_id": "post/2023-12-27-tiptap.md",
    "_raw": {
      "sourceFilePath": "post/2023-12-27-tiptap.md",
      "sourceFileName": "2023-12-27-tiptap.md",
      "sourceFileDir": "post",
      "contentType": "markdown",
      "flattenedPath": "post/2023-12-27-tiptap"
    },
    "type": "Post",
    "id": ""
  },
  {
    "title": "使用pont实现swagger文档生成ts响应类型",
    "url": "/2023-12-28-pont-apiDoc",
    "date": "2023-12-28T00:00:00.000Z",
    "body": {
      "raw": "https://blog.csdn.net/m0_65035567/article/details/130278459\n\n> 之前用过字节的ferry， 可以很方便讲thrift文件转成.d.ts类型定义和接口请求文件。但是ferry现在不开源，找到pont，可以把swagger转成ts。尝试接入现有的项目中\n\n## pont\npont是阿里出的一个工具，它可以非常方便的把后端的swagger文档转成ts提示类型，不仅如此，它还支持添加模板，直接生成对应的接口请求，甚至能帮我们生成请求参数的默认基类。\n\nGithub：[github.com/alibaba/pon…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fpont \"https://github.com/alibaba/pont\")\n\n## usage\n1. 全局安装 `yarn add -D pont-engine`\n2. 安装 vscode 插件 pont 以获取 pont 的全部能力\n3. 进入项目目录，在项目中安装 pont-engine\n4. 新建`pont-config.json`， 也可以`pont start`按照提示生成。 [配置参考](https://github.com/alibaba/pont/blob/master/docs/pontConfig.md)\n5. 新建`pontTemplate.ts` 生成自定义接口代码\n\n## API\n### cmd\n\n> 很奇怪，竟然没有代码生成的命令，只能利用vscode插件生成完成之后利用updateMod去更新\n\n\n\n|  cmd |  description |\n|---|---|\n|pont start|一键接入 pont，若本地存在 [pont-config.json](https://github.com/alibaba/pont/blob/master/docs/pontConfig.md)配置文件，将覆盖重复的配置项|\n|pont check|校验本地的 pont-lock.json 文件是否缺失、损坏。建议用户在项目中，在 pre-commit 里加上 pont check 命令，以防止在团队协作过程中，pont-lock.json 被误删、解决该文件冲突时被损坏等情况|\n|pont scan|扫描未使用的接口，在 process.cwd()位置生成并写入 unusedRequests.json 文件，需要配置 scannedRange。请参考 [pont-config.json 配置项](https://github.com/alibaba/pont/blob/master/docs/pontConfig.md)|\n|pont ls|查看所有数据源|\n|pont select [dsName]|切换当前数据源|\n|pont diff|查看远程数据和本地数据在模块、基类上的差异，以作针对性、选择性同步|\n|pont updateMod [modName]|选择性更新本地的模块|\n|pont updateBo [boName]|选择性更新本地的基类|\n\n### pontConfig\n- **originUrl**: swagger文档的json数据\n- **outDir**：生成的文件位置\n- **originType**：swagger文档类型 SwaggerV3/SwaggerV2\n- **templatePath**：生成的接口模板位置\n\n```json\n{\n    \"originUrl\": \"https://petstore.swagger.io/v2/swagger.json\",\n    \"outDir\": \"./apis\",\n    \"originType\": \"SwaggerV3\",\n    \"templatePath\": \"./pontTemplate\",\n}\n```\n\n\n\n### pontTemplate  // todo\n```ts\nexport default class MyGenerator extends CodeGenerator {}\n```",
      "html": "<p>https://blog.csdn.net/m0_65035567/article/details/130278459</p>\n<blockquote>\n<p>之前用过字节的ferry， 可以很方便讲thrift文件转成.d.ts类型定义和接口请求文件。但是ferry现在不开源，找到pont，可以把swagger转成ts。尝试接入现有的项目中</p>\n</blockquote>\n<h2>pont</h2>\n<p>pont是阿里出的一个工具，它可以非常方便的把后端的swagger文档转成ts提示类型，不仅如此，它还支持添加模板，直接生成对应的接口请求，甚至能帮我们生成请求参数的默认基类。</p>\n<p>Github：<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fpont\" title=\"https://github.com/alibaba/pont\">github.com/alibaba/pon…</a></p>\n<h2>usage</h2>\n<ol>\n<li>全局安装 <code>yarn add -D pont-engine</code></li>\n<li>安装 vscode 插件 pont 以获取 pont 的全部能力</li>\n<li>进入项目目录，在项目中安装 pont-engine</li>\n<li>新建<code>pont-config.json</code>， 也可以<code>pont start</code>按照提示生成。 <a href=\"https://github.com/alibaba/pont/blob/master/docs/pontConfig.md\">配置参考</a></li>\n<li>新建<code>pontTemplate.ts</code> 生成自定义接口代码</li>\n</ol>\n<h2>API</h2>\n<h3>cmd</h3>\n<blockquote>\n<p>很奇怪，竟然没有代码生成的命令，只能利用vscode插件生成完成之后利用updateMod去更新</p>\n</blockquote>\n<p>|  cmd |  description |\n|---|---|\n|pont start|一键接入 pont，若本地存在 <a href=\"https://github.com/alibaba/pont/blob/master/docs/pontConfig.md\">pont-config.json</a>配置文件，将覆盖重复的配置项|\n|pont check|校验本地的 pont-lock.json 文件是否缺失、损坏。建议用户在项目中，在 pre-commit 里加上 pont check 命令，以防止在团队协作过程中，pont-lock.json 被误删、解决该文件冲突时被损坏等情况|\n|pont scan|扫描未使用的接口，在 process.cwd()位置生成并写入 unusedRequests.json 文件，需要配置 scannedRange。请参考 <a href=\"https://github.com/alibaba/pont/blob/master/docs/pontConfig.md\">pont-config.json 配置项</a>|\n|pont ls|查看所有数据源|\n|pont select [dsName]|切换当前数据源|\n|pont diff|查看远程数据和本地数据在模块、基类上的差异，以作针对性、选择性同步|\n|pont updateMod [modName]|选择性更新本地的模块|\n|pont updateBo [boName]|选择性更新本地的基类|</p>\n<h3>pontConfig</h3>\n<ul>\n<li><strong>originUrl</strong>: swagger文档的json数据</li>\n<li><strong>outDir</strong>：生成的文件位置</li>\n<li><strong>originType</strong>：swagger文档类型 SwaggerV3/SwaggerV2</li>\n<li><strong>templatePath</strong>：生成的接口模板位置</li>\n</ul>\n<pre><code class=\"language-json\">{\n    \"originUrl\": \"https://petstore.swagger.io/v2/swagger.json\",\n    \"outDir\": \"./apis\",\n    \"originType\": \"SwaggerV3\",\n    \"templatePath\": \"./pontTemplate\",\n}\n</code></pre>\n<h3>pontTemplate  // todo</h3>\n<pre><code class=\"language-ts\">export default class MyGenerator extends CodeGenerator {}\n</code></pre>"
    },
    "_id": "post/2023-12-28-swagger2ts-pont.md",
    "_raw": {
      "sourceFilePath": "post/2023-12-28-swagger2ts-pont.md",
      "sourceFileName": "2023-12-28-swagger2ts-pont.md",
      "sourceFileDir": "post",
      "contentType": "markdown",
      "flattenedPath": "post/2023-12-28-swagger2ts-pont"
    },
    "type": "Post",
    "id": ""
  },
  {
    "title": "鉴权方式",
    "url": "/2023-12-07-secret",
    "description": "",
    "date": "2023-11-25T00:00:00.000Z",
    "body": {
      "raw": "\n> 常见的鉴权方式有以下几种方式：\n>\n> 1. token\n> 2. session + cookie\n> 3. OAuth\n\n## token\n\n### 流程\n\n1. 客户端使用账密登录\n2. 服务端验证账密\n3. 账密验证通过，服务端生成一个token，再把token发送给客户端\n4. 客户端通过cookie或者其他方式将token存储起来\n5. 客户端以后发送请求都需要带上token\n6. 服务端验证token的合法性，校验通过则返回资源，不通过则返回401状态码\n\n\n\n\n\n\n\n\n\n\n",
      "html": "<blockquote>\n<p>常见的鉴权方式有以下几种方式：</p>\n<ol>\n<li>token</li>\n<li>session + cookie</li>\n<li>OAuth</li>\n</ol>\n</blockquote>\n<h2>token</h2>\n<h3>流程</h3>\n<ol>\n<li>客户端使用账密登录</li>\n<li>服务端验证账密</li>\n<li>账密验证通过，服务端生成一个token，再把token发送给客户端</li>\n<li>客户端通过cookie或者其他方式将token存储起来</li>\n<li>客户端以后发送请求都需要带上token</li>\n<li>服务端验证token的合法性，校验通过则返回资源，不通过则返回401状态码</li>\n</ol>"
    },
    "_id": "post/2023-12-7-authentication.md",
    "_raw": {
      "sourceFilePath": "post/2023-12-7-authentication.md",
      "sourceFileName": "2023-12-7-authentication.md",
      "sourceFileDir": "post",
      "contentType": "markdown",
      "flattenedPath": "post/2023-12-7-authentication"
    },
    "type": "Post",
    "id": ""
  },
  {
    "title": "git详细使用",
    "url": "/2024-01-12-git",
    "date": "2024-01-12T00:00:00.000Z",
    "body": {
      "raw": "> 基础的git知识不重复了，记录一些在实践应用中会需要的命令要点\n\n![](https://raw.githubusercontent.com/heavenmei/heavenmei.github.io/master/images/202401121443587.png)\n\n## 基本操作\n**git add** \n\n**git commit**\n- `--amend`： 修改git提交记录用法,本质上就是生成了新的commit，替代了上一次commit的位置\n- \n\n**git push**\n\n**git status**\n\n**git fetch**\n\n**git pull**\ngit pull = git fetch + git merge\ngit pull --rebase = git fetch + git rebase\n\n- `-r`/`--rebase`: rebase\n\n**git branch**\n列出，创建或删除分支\n- 无参数： 没有参数时，**git branch** 会列出你在本地的分支。\n- `git branch <branch_name>`： 创建分支\n- `-d <branch_name>`： 删除分支\n\n**git checkout**\n- `git checkout <branch_name>` 切换分支\n- `-b <new_branch>`: 创建一个名为<new_branch>的新分支并在<start_point>处启动它\n\n**git remote**\n\n\n**git stash:**\n将变化储存的工作目录中\n`git stash pop`： 恢复缓存\n\n\n**git log**\n命令显示从最近到最远的提交日志\n## 合并\n#### git merge\n**两种用途：**\n1. 用于git-pull中，来整合另一代码仓库中的变化（即：git pull = git fetch + git merge）\n2. 用于从一个分支到另一个分支的合并\n\n**合并策略**：Git merge有两种主要的合并策略：fast-forward和recursive。\n**fast-forward**：默认，当前分支合并到另一分支时，如果没有分歧解决，就会直接移动文件指针。\n例如：假设存在以下历史记录，创建topic分支后主分支没有任何提交，并且当前分支是\"master\"\n```shell\n          A---B---C topic\n         /\n    D---E master\n```\n然后 `git merge topic`将会把ABC节点与E节点连接，直接移动HEAD指针\n```shell\n          A---B---C topic\n         /\n    D---E---A---B---C master\n```\n\n\n**recursive**：Git会创建一个新的提交来表示合并结果，这个提交会包含两个分支的所有变更内容。\n例如：假设存在以下历史记录，并且当前分支是\"master\"：\n```shell\n          A---B---C topic\n         /\n    D---E---F---G master\n```\n\n然后 `git merge topic`将会把ABC节点与G节点合并，并且将结果记录在新的提交H中。C节点和G节点都是H节点的父节点。\n\n```shell\n          A---B---C topic\n         /         \\\n    D---E---F---G---H master\n```\n\n\n\n**子命令**\n- `--abort`：抛弃当前合并冲突的处理过程并尝试重建合并前的状态。\n- `--continue`：由于冲突停止后，您可以通过运行来结束合并\n- `--ff`：当合并策略为fast-forward时，只更新分支指针，而不创建合并提交。这是默认行为。\n- `--no-ff`：即使合并策略为fast-forward，也可以创建合并提交。这是合并tag时的默认行为。\n- `--squash`：将合并结果压缩为一个提交，并且不会保留源分支的提交历史。（与`--no-ff`冲突）\n\n**参数**\n- `-m <message>`：指定新的合并提交的提交信息。\n\n\n#### git rebase\n变基，改变基底\n例如：假设存在以下历史记录，并且当前分支是\"topic\"：\n```text\n          C---D topic\n         /\n    A---B---M master\n```\n\n此时我们在topic分支上，执行rebase命令，相当于是想要把master分支合并到topic分支（这一步的场景就可以类比为我们在自己的分支 topic 上开发了一段时间了，准备从主干master上拉一下最新改动。模拟了`git pull --rebase`的情形）\n```shell\n# 这两条命令等价于git rebase master topic\ngit checkout topic\ngit rebase master\n```\n此时历史记录变成:**注意这里的接法，实际是会依次拿M和C、D内容分别比较，处理冲突后生成新的C’和D’，然后删除原本的CD提交**，相当于topic分支的基底由原来的B变成了M（主分支最新的提交）\n```text\n\t          C‘---D’ topic\n\t         /\n    A---B---M master\n```\n\n注意，如果master上在B以后没有新提交，那么就还是用原来的B作为基，rebase操作相当于无效，此时和git merge就基本没区别了，**差异只在于git merge会多一条记录Merge操作的提交记录**\n\n> 上面的例子可抽象为如下实际工作场景：\n> 远程库上有一个master分支目前开发到B了，张三从B拉了代码到本地的 topic 分支进行开发，目前提交了两次，开发到D了；李四也从B拉到本地的master分支，他提交到了M，然后合到远程库的master上了。此时张三想从远程库master拉下最新代码，于是他在feature分支上执行了git pull origin master:topic --rebase（注意要加–rebase参数），即把远程库master分支给rebase下来，\n> 由于李四更早开发完，此时远程master上是李四的最新内容，rebase后再看张三的历史提交记录，就相当于是张三是基于李四的最新提交M进行的开发了。（但实际上张三更早拉代码下来，李四拉的晚但提交早）\n\n\n## 回滚\n#### git reflog\n查看命令历史，以便确定要回到未来的哪个版本\n\n#### git reset\n将当前 HEAD 重置为指定状态\n```shell\n     git add . ------------> git commit -m 说明 -------------> git push\n   (添加到暂存区)              （提交到本地仓库）             （推送到远程仓库）\n```\n**子命令**\n- `--soft`:该命令表示撤销代码到暂存区之后，`commit`之前，代码在本地不会改变。\n- `--mixed`:该命令表示撤销代码到暂存区和`commit`之前，代码在本地不会改变。\n- `--hard`:该命令表示回退代码到某个版本下，代码在本地会改变到指定版本下，谨慎操作。\n\n\n#### git revert\n恢复一些现有的提交\n\n**子命令**\n- `--abort`： 取消操作并返回到预序列状态。\n\n**参数**\n- `-n`: --no-commit,该命令会自动创建一些提交日志消息，提交哪些提交已恢复。此标志应用必要的更改以将命名的提交恢复到您的工作树和索引，但不进行提交。\n- \n\n\n#### reset vs revert\nreset和revert都可以用来回滚代码。但他们是有区别的：\n- reset是用来\"回退\"版本，删除原本的commit记录\n- revert是用来\"还原\"某次或者某几次提交。生成新的一条commit记录\n\n例如，在master分支，有以下提交历史:\n\n```text\n42eae13 (HEAD -> master) 第四次修改\n97ea0f9 第三次修改\ne50b7c2 第二次修改\n3a52650 第一次修改\n```\n\n执行 `git reset --hard 97ea0f9`,这个时候，git的提交历史变为:\n\n```text\n97ea0f9 (HEAD -> master) 第三次修改\ne50b7c2 第二次修改\n3a52650 第一次修改\n```\n\n可以看到master当前指向97ea0f9这个版本，我们回到了第三次修改。\n但是如果执行 `git revert -n 97ea0f9`, 然后重新commit `git commit -m \"恢复第三次修改\"`,\n```text\n33b8b30 (HEAD -> master) Revert \"恢复第三次修改\"\n42eae13 第四次修改\n97ea0f9 第三次修改\ne50b7c2 第二次修改\n3a52650 第一次修改\n```\nGit把第三次修改从提交中剔除(还原)了，还保留了第四次修改，并且产生了新的commit_id。\n\n\n\n## 实际应用\n[一个成功的Git分支模型](https://www.jianshu.com/p/b357df6794e3)\n### git如何把master合并到自己分支\n1. 切换到主分支 `git chekout master`\n2. pull到本地 `git pull`\n3. 切换到自己的分支 `git checkout xxx`\n4. 把主分支merge到自己的分支 `git merge master`\n5. 最后push，自己分支就与主分支拉齐了\n\n### 如何解决冲突\n看到冲突后，你可以做两件事：\n- 决定不合并。`git merge --abort`\n- 解决冲突。重新add/commit 或者`git merge --continue`密封交易。continue在调用之前检查是否存在正在进行的（中断的）合并`git commit`。然后在push\n\n###  Git Clone 速度太慢的问题\n1. https://whatismyipaddress.com/hostname-ip 到这个网站查找git IP\n2. 或者`nslookup` 进行域名解析， git 相关地址的 `IP Address`，配置到 hosts 中\n```shell\nnslookup github.com\nnslookup github.global.ssl.fastly.net\n```\n3. `ping github.com`成功\n4. 修改 hosts 文件 `sudo vim /etc/host` , 在hosts最后追加\n```shell\n180.168.255.118 github.global.ssl.fastly.net\n180.168.255.118 github.com\n```\n\n\n### .gitignore 不生效\n原因是 .gitignore 只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。  \n那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交。\n```shell\ngit rm -r --cached .\n\ngit add .\n\ngit commit -m 'update .gitignore'\n```\n\n\n###  git Recv failure: Connection was reset\n移除旧的origin ：`git remote remove origin`  \n再重新建立新的origin ： `git remote add origin xxx`\n重新push就可以了",
      "html": "<blockquote>\n<p>基础的git知识不重复了，记录一些在实践应用中会需要的命令要点</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/heavenmei/heavenmei.github.io/master/images/202401121443587.png\" alt=\"\"></p>\n<h2>基本操作</h2>\n<p><strong>git add</strong></p>\n<p><strong>git commit</strong></p>\n<ul>\n<li><code>--amend</code>： 修改git提交记录用法,本质上就是生成了新的commit，替代了上一次commit的位置</li>\n<li></li>\n</ul>\n<p><strong>git push</strong></p>\n<p><strong>git status</strong></p>\n<p><strong>git fetch</strong></p>\n<p><strong>git pull</strong>\ngit pull = git fetch + git merge\ngit pull --rebase = git fetch + git rebase</p>\n<ul>\n<li><code>-r</code>/<code>--rebase</code>: rebase</li>\n</ul>\n<p><strong>git branch</strong>\n列出，创建或删除分支</p>\n<ul>\n<li>无参数： 没有参数时，<strong>git branch</strong> 会列出你在本地的分支。</li>\n<li><code>git branch &#x3C;branch_name></code>： 创建分支</li>\n<li><code>-d &#x3C;branch_name></code>： 删除分支</li>\n</ul>\n<p><strong>git checkout</strong></p>\n<ul>\n<li><code>git checkout &#x3C;branch_name></code> 切换分支</li>\n<li><code>-b &#x3C;new_branch></code>: 创建一个名为&#x3C;new_branch>的新分支并在&#x3C;start_point>处启动它</li>\n</ul>\n<p><strong>git remote</strong></p>\n<p><strong>git stash:</strong>\n将变化储存的工作目录中\n<code>git stash pop</code>： 恢复缓存</p>\n<p><strong>git log</strong>\n命令显示从最近到最远的提交日志</p>\n<h2>合并</h2>\n<h4>git merge</h4>\n<p><strong>两种用途：</strong></p>\n<ol>\n<li>用于git-pull中，来整合另一代码仓库中的变化（即：git pull = git fetch + git merge）</li>\n<li>用于从一个分支到另一个分支的合并</li>\n</ol>\n<p><strong>合并策略</strong>：Git merge有两种主要的合并策略：fast-forward和recursive。\n<strong>fast-forward</strong>：默认，当前分支合并到另一分支时，如果没有分歧解决，就会直接移动文件指针。\n例如：假设存在以下历史记录，创建topic分支后主分支没有任何提交，并且当前分支是\"master\"</p>\n<pre><code class=\"language-shell\">          A---B---C topic\n         /\n    D---E master\n</code></pre>\n<p>然后 <code>git merge topic</code>将会把ABC节点与E节点连接，直接移动HEAD指针</p>\n<pre><code class=\"language-shell\">          A---B---C topic\n         /\n    D---E---A---B---C master\n</code></pre>\n<p><strong>recursive</strong>：Git会创建一个新的提交来表示合并结果，这个提交会包含两个分支的所有变更内容。\n例如：假设存在以下历史记录，并且当前分支是\"master\"：</p>\n<pre><code class=\"language-shell\">          A---B---C topic\n         /\n    D---E---F---G master\n</code></pre>\n<p>然后 <code>git merge topic</code>将会把ABC节点与G节点合并，并且将结果记录在新的提交H中。C节点和G节点都是H节点的父节点。</p>\n<pre><code class=\"language-shell\">          A---B---C topic\n         /         \\\n    D---E---F---G---H master\n</code></pre>\n<p><strong>子命令</strong></p>\n<ul>\n<li><code>--abort</code>：抛弃当前合并冲突的处理过程并尝试重建合并前的状态。</li>\n<li><code>--continue</code>：由于冲突停止后，您可以通过运行来结束合并</li>\n<li><code>--ff</code>：当合并策略为fast-forward时，只更新分支指针，而不创建合并提交。这是默认行为。</li>\n<li><code>--no-ff</code>：即使合并策略为fast-forward，也可以创建合并提交。这是合并tag时的默认行为。</li>\n<li><code>--squash</code>：将合并结果压缩为一个提交，并且不会保留源分支的提交历史。（与<code>--no-ff</code>冲突）</li>\n</ul>\n<p><strong>参数</strong></p>\n<ul>\n<li><code>-m &#x3C;message></code>：指定新的合并提交的提交信息。</li>\n</ul>\n<h4>git rebase</h4>\n<p>变基，改变基底\n例如：假设存在以下历史记录，并且当前分支是\"topic\"：</p>\n<pre><code class=\"language-text\">          C---D topic\n         /\n    A---B---M master\n</code></pre>\n<p>此时我们在topic分支上，执行rebase命令，相当于是想要把master分支合并到topic分支（这一步的场景就可以类比为我们在自己的分支 topic 上开发了一段时间了，准备从主干master上拉一下最新改动。模拟了<code>git pull --rebase</code>的情形）</p>\n<pre><code class=\"language-shell\"># 这两条命令等价于git rebase master topic\ngit checkout topic\ngit rebase master\n</code></pre>\n<p>此时历史记录变成:<strong>注意这里的接法，实际是会依次拿M和C、D内容分别比较，处理冲突后生成新的C’和D’，然后删除原本的CD提交</strong>，相当于topic分支的基底由原来的B变成了M（主分支最新的提交）</p>\n<pre><code class=\"language-text\">\t          C‘---D’ topic\n\t         /\n    A---B---M master\n</code></pre>\n<p>注意，如果master上在B以后没有新提交，那么就还是用原来的B作为基，rebase操作相当于无效，此时和git merge就基本没区别了，<strong>差异只在于git merge会多一条记录Merge操作的提交记录</strong></p>\n<blockquote>\n<p>上面的例子可抽象为如下实际工作场景：\n远程库上有一个master分支目前开发到B了，张三从B拉了代码到本地的 topic 分支进行开发，目前提交了两次，开发到D了；李四也从B拉到本地的master分支，他提交到了M，然后合到远程库的master上了。此时张三想从远程库master拉下最新代码，于是他在feature分支上执行了git pull origin master:topic --rebase（注意要加–rebase参数），即把远程库master分支给rebase下来，\n由于李四更早开发完，此时远程master上是李四的最新内容，rebase后再看张三的历史提交记录，就相当于是张三是基于李四的最新提交M进行的开发了。（但实际上张三更早拉代码下来，李四拉的晚但提交早）</p>\n</blockquote>\n<h2>回滚</h2>\n<h4>git reflog</h4>\n<p>查看命令历史，以便确定要回到未来的哪个版本</p>\n<h4>git reset</h4>\n<p>将当前 HEAD 重置为指定状态</p>\n<pre><code class=\"language-shell\">     git add . ------------> git commit -m 说明 -------------> git push\n   (添加到暂存区)              （提交到本地仓库）             （推送到远程仓库）\n</code></pre>\n<p><strong>子命令</strong></p>\n<ul>\n<li><code>--soft</code>:该命令表示撤销代码到暂存区之后，<code>commit</code>之前，代码在本地不会改变。</li>\n<li><code>--mixed</code>:该命令表示撤销代码到暂存区和<code>commit</code>之前，代码在本地不会改变。</li>\n<li><code>--hard</code>:该命令表示回退代码到某个版本下，代码在本地会改变到指定版本下，谨慎操作。</li>\n</ul>\n<h4>git revert</h4>\n<p>恢复一些现有的提交</p>\n<p><strong>子命令</strong></p>\n<ul>\n<li><code>--abort</code>： 取消操作并返回到预序列状态。</li>\n</ul>\n<p><strong>参数</strong></p>\n<ul>\n<li><code>-n</code>: --no-commit,该命令会自动创建一些提交日志消息，提交哪些提交已恢复。此标志应用必要的更改以将命名的提交恢复到您的工作树和索引，但不进行提交。</li>\n<li></li>\n</ul>\n<h4>reset vs revert</h4>\n<p>reset和revert都可以用来回滚代码。但他们是有区别的：</p>\n<ul>\n<li>reset是用来\"回退\"版本，删除原本的commit记录</li>\n<li>revert是用来\"还原\"某次或者某几次提交。生成新的一条commit记录</li>\n</ul>\n<p>例如，在master分支，有以下提交历史:</p>\n<pre><code class=\"language-text\">42eae13 (HEAD -> master) 第四次修改\n97ea0f9 第三次修改\ne50b7c2 第二次修改\n3a52650 第一次修改\n</code></pre>\n<p>执行 <code>git reset --hard 97ea0f9</code>,这个时候，git的提交历史变为:</p>\n<pre><code class=\"language-text\">97ea0f9 (HEAD -> master) 第三次修改\ne50b7c2 第二次修改\n3a52650 第一次修改\n</code></pre>\n<p>可以看到master当前指向97ea0f9这个版本，我们回到了第三次修改。\n但是如果执行 <code>git revert -n 97ea0f9</code>, 然后重新commit <code>git commit -m \"恢复第三次修改\"</code>,</p>\n<pre><code class=\"language-text\">33b8b30 (HEAD -> master) Revert \"恢复第三次修改\"\n42eae13 第四次修改\n97ea0f9 第三次修改\ne50b7c2 第二次修改\n3a52650 第一次修改\n</code></pre>\n<p>Git把第三次修改从提交中剔除(还原)了，还保留了第四次修改，并且产生了新的commit_id。</p>\n<h2>实际应用</h2>\n<p><a href=\"https://www.jianshu.com/p/b357df6794e3\">一个成功的Git分支模型</a></p>\n<h3>git如何把master合并到自己分支</h3>\n<ol>\n<li>切换到主分支 <code>git chekout master</code></li>\n<li>pull到本地 <code>git pull</code></li>\n<li>切换到自己的分支 <code>git checkout xxx</code></li>\n<li>把主分支merge到自己的分支 <code>git merge master</code></li>\n<li>最后push，自己分支就与主分支拉齐了</li>\n</ol>\n<h3>如何解决冲突</h3>\n<p>看到冲突后，你可以做两件事：</p>\n<ul>\n<li>决定不合并。<code>git merge --abort</code></li>\n<li>解决冲突。重新add/commit 或者<code>git merge --continue</code>密封交易。continue在调用之前检查是否存在正在进行的（中断的）合并<code>git commit</code>。然后在push</li>\n</ul>\n<h3>Git Clone 速度太慢的问题</h3>\n<ol>\n<li>https://whatismyipaddress.com/hostname-ip 到这个网站查找git IP</li>\n<li>或者<code>nslookup</code> 进行域名解析， git 相关地址的 <code>IP Address</code>，配置到 hosts 中</li>\n</ol>\n<pre><code class=\"language-shell\">nslookup github.com\nnslookup github.global.ssl.fastly.net\n</code></pre>\n<ol start=\"3\">\n<li><code>ping github.com</code>成功</li>\n<li>修改 hosts 文件 <code>sudo vim /etc/host</code> , 在hosts最后追加</li>\n</ol>\n<pre><code class=\"language-shell\">180.168.255.118 github.global.ssl.fastly.net\n180.168.255.118 github.com\n</code></pre>\n<h3>.gitignore 不生效</h3>\n<p>原因是 .gitignore 只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。<br>\n那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交。</p>\n<pre><code class=\"language-shell\">git rm -r --cached .\n\ngit add .\n\ngit commit -m 'update .gitignore'\n</code></pre>\n<h3>git Recv failure: Connection was reset</h3>\n<p>移除旧的origin ：<code>git remote remove origin</code><br>\n再重新建立新的origin ： <code>git remote add origin xxx</code>\n重新push就可以了</p>"
    },
    "_id": "post/2024-01-12-Git.md",
    "_raw": {
      "sourceFilePath": "post/2024-01-12-Git.md",
      "sourceFileName": "2024-01-12-Git.md",
      "sourceFileDir": "post",
      "contentType": "markdown",
      "flattenedPath": "post/2024-01-12-Git"
    },
    "type": "Post",
    "id": ""
  },
  {
    "title": "modal变成悬浮panel",
    "url": "/2024-01-17-modal2panel",
    "date": "2024-01-17T00:00:00.000Z",
    "body": {
      "raw": "",
      "html": ""
    },
    "_id": "post/2024-01-17-Modal2Panel.md",
    "_raw": {
      "sourceFilePath": "post/2024-01-17-Modal2Panel.md",
      "sourceFileName": "2024-01-17-Modal2Panel.md",
      "sourceFileDir": "post",
      "contentType": "markdown",
      "flattenedPath": "post/2024-01-17-Modal2Panel"
    },
    "type": "Post",
    "id": ""
  },
  {
    "title": "ubuntu Clash 科学上网",
    "url": "/2024-07-29-Clash",
    "description": "装环境实在太麻烦啦，mark一些安装命令，以备不时之需。",
    "date": "2023-11-25T00:00:00.000Z",
    "body": {
      "raw": "下载文件 `clash-linux-amd64-v1.17.0.gz`\n> 链接: https://pan.baidu.com/s/1RzYl_CGHLF9IUS9I5xyvZg?pwd=53kc 提取码: 53kc\n\n解压：`gunzip clash-linux-amd64-v1.17.0.gz`\n移动重命名： `sudo mv clash-linux-amd64-v1.17.0 /usr/local/bin/clash`\n给 Clash 添加执行权限：`sudo chmod +x /usr/local/bin/clash`\n启动 Clash自动创建initial config file：`clash -d ~/.config/clash`\n替换订阅文件：`curl https:/xxxx.yaml > ~/.config/clash/config.yaml`（或者手动复制）\n启动 Clash：`clash -d ~/.config/clash`\n写入 ~/zshrc\n\n```json\necho 'export http_proxy=127.0.0.1:7890' >> ~/.zshrc\necho 'export https_proxy=$http_proxy' >> ~/.zshrc\n```\n\n**开机自启配置：**[https://blog.csdn.net/xiaxinkai/article/details/123563488](https://blog.csdn.net/xiaxinkai/article/details/123563488)\n\n`sudo vim /etc/systemd/system/clash.service`\n\n写入配置\n\n```json\n[Unit]\nDescription=clash service\nAfter=network.target\n \n[Service]\nExecStart=/usr/local/bin/clash -d /home/haiwen/.config/clash/\n \n[Install]\nWantedBy=multi-user.target\n```\n\n`sudo systemctl daemon-reload # 刷新配置` `sudo systemctl start clash # 启动clash.service` `sudo systemctl enable clash # 设置开机启动` `sudo systemctl status clash # 查看clash.service的状态`",
      "html": "<p>下载文件 <code>clash-linux-amd64-v1.17.0.gz</code></p>\n<blockquote>\n<p>链接: https://pan.baidu.com/s/1RzYl_CGHLF9IUS9I5xyvZg?pwd=53kc 提取码: 53kc</p>\n</blockquote>\n<p>解压：<code>gunzip clash-linux-amd64-v1.17.0.gz</code>\n移动重命名： <code>sudo mv clash-linux-amd64-v1.17.0 /usr/local/bin/clash</code>\n给 Clash 添加执行权限：<code>sudo chmod +x /usr/local/bin/clash</code>\n启动 Clash自动创建initial config file：<code>clash -d ~/.config/clash</code>\n替换订阅文件：<code>curl https:/xxxx.yaml > ~/.config/clash/config.yaml</code>（或者手动复制）\n启动 Clash：<code>clash -d ~/.config/clash</code>\n写入 ~/zshrc</p>\n<pre><code class=\"language-json\">echo 'export http_proxy=127.0.0.1:7890' >> ~/.zshrc\necho 'export https_proxy=$http_proxy' >> ~/.zshrc\n</code></pre>\n<p><strong>开机自启配置：</strong><a href=\"https://blog.csdn.net/xiaxinkai/article/details/123563488\">https://blog.csdn.net/xiaxinkai/article/details/123563488</a></p>\n<p><code>sudo vim /etc/systemd/system/clash.service</code></p>\n<p>写入配置</p>\n<pre><code class=\"language-json\">[Unit]\nDescription=clash service\nAfter=network.target\n \n[Service]\nExecStart=/usr/local/bin/clash -d /home/haiwen/.config/clash/\n \n[Install]\nWantedBy=multi-user.target\n</code></pre>\n<p><code>sudo systemctl daemon-reload # 刷新配置</code> <code>sudo systemctl start clash # 启动clash.service</code> <code>sudo systemctl enable clash # 设置开机启动</code> <code>sudo systemctl status clash # 查看clash.service的状态</code></p>"
    },
    "_id": "post/2024-07-29-Clash.md",
    "_raw": {
      "sourceFilePath": "post/2024-07-29-Clash.md",
      "sourceFileName": "2024-07-29-Clash.md",
      "sourceFileDir": "post",
      "contentType": "markdown",
      "flattenedPath": "post/2024-07-29-Clash"
    },
    "type": "Post",
    "id": ""
  },
  {
    "title": "ubuntu Docker 配置",
    "url": "/2024-07-29-Clash",
    "description": "装环境实在太麻烦啦，mark一些安装命令，以备不时之需。",
    "date": "2024-07-29T00:00:00.000Z",
    "body": {
      "raw": "\n\n\n### docker pull 加速\n在挂了clash代理后docker pull的速度非常慢，后来得知docker不走系统代理，原来docker需要单独配置代理\n\n1. 使用 `sudo systemctl edit docker.service`编辑 Docker 的 systemd 服务文件\n```bash\n[Service]\nEnvironment=\"HTTP_PROXY=http://127.0.0.1:7890\"\nEnvironment=\"HTTPS_PROXY=http://127.0.0.1:7890\"\nEnvironment=\"NO_PROXY=localhost,127.0.0.1,docker-registry.example.com\"\n```\n2. `ctrl+o`保存,`ctrl+x`关闭编辑器\n3. 使用`sudo systemctl daemon-reload`重载docker配置\n4. 使用`sudo systemctl restart docker`重启docker进程守护\n5. 再次进行docker pull\n\n\nhttps://blog.ohmykreee.top/article/deploy-nextjs-static-page-to-github-pages/",
      "html": "<h3>docker pull 加速</h3>\n<p>在挂了clash代理后docker pull的速度非常慢，后来得知docker不走系统代理，原来docker需要单独配置代理</p>\n<ol>\n<li>使用 <code>sudo systemctl edit docker.service</code>编辑 Docker 的 systemd 服务文件</li>\n</ol>\n<pre><code class=\"language-bash\">[Service]\nEnvironment=\"HTTP_PROXY=http://127.0.0.1:7890\"\nEnvironment=\"HTTPS_PROXY=http://127.0.0.1:7890\"\nEnvironment=\"NO_PROXY=localhost,127.0.0.1,docker-registry.example.com\"\n</code></pre>\n<ol start=\"2\">\n<li><code>ctrl+o</code>保存,<code>ctrl+x</code>关闭编辑器</li>\n<li>使用<code>sudo systemctl daemon-reload</code>重载docker配置</li>\n<li>使用<code>sudo systemctl restart docker</code>重启docker进程守护</li>\n<li>再次进行docker pull</li>\n</ol>\n<p>https://blog.ohmykreee.top/article/deploy-nextjs-static-page-to-github-pages/</p>"
    },
    "_id": "post/2024-07-29-Docker.md",
    "_raw": {
      "sourceFilePath": "post/2024-07-29-Docker.md",
      "sourceFileName": "2024-07-29-Docker.md",
      "sourceFileDir": "post",
      "contentType": "markdown",
      "flattenedPath": "post/2024-07-29-Docker"
    },
    "type": "Post",
    "id": ""
  }
]